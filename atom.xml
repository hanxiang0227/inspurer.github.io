<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月小水长的个人博客</title>
  
  <subtitle>十年饮冰，热血未凉。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://inspurer.github.io/"/>
  <updated>2019-03-22T15:35:08.713Z</updated>
  <id>https://inspurer.github.io/</id>
  
  <author>
    <name>月小水长</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT (Advanced Level) Practice No.1001</title>
    <link href="https://inspurer.github.io/2019/03/22/PAT-Advanced-Level-Practice-No-1001/"/>
    <id>https://inspurer.github.io/2019/03/22/PAT-Advanced-Level-Practice-No-1001/</id>
    <published>2019-03-22T15:17:14.000Z</published>
    <updated>2019-03-22T15:35:08.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><h3 id="001-A-B-Format-（20-分"><a href="#001-A-B-Format-（20-分" class="headerlink" title="001 A+B Format （20 分)"></a>001 A+B Format （20 分)</h3><p>Calculate a+b and output the sum in standard format<a id="more"></a> – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).<br>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers a and b where −10​6​​≤a,b≤10​6​​. The numbers are separated by a space.<br>Output Specification:</p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><p>-1000000 9</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><p>-999,991</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code>import java.util.LinkedList;import java.util.Scanner;//CreateTime: 2019/3/21 23:21//Author:     月小水长(https://github.com/inspurer)/*    类名:首字母大写，其他单词中首字母大写，其他小写    方法名:首字母小写，其他单词中首字母大写，其他小写    变量:与方法名规则同    包名:全部小写*/public class Main {    public static void main(String [] args){        Scanner scanner = new Scanner(System.in);        int num1 = Integer.parseInt(scanner.next());        int num2 = Integer.parseInt(scanner.next());        scanner.close();        num1 += num2;        int flag = num1&gt;=0?1:0;        num1 = num1&gt;0?num1:-num1;        if(String.valueOf(num1).length()&lt;4) {            if (flag == 0) {                System.out.print(-num1);            } else {                System.out.print(num1);            }            return;        }        LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();        do{            result.add(String.valueOf(num1%10));            num1 /= 10;            if((result.size()+1)%4==0&amp;&amp;num1&gt;0){                result.add(&quot;,&quot;);            }        }while (num1&gt;0);        if(flag==0){            result.add(&quot;-&quot;);        }        for(int i = result.size()-1;i&gt;=0;i--)            System.out.print(result.get(i));    }}</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Scanner.nextInt() 方法只能接收正整数，如输入负整数则会忽略掉掉负号，相当于对输入取 abs() ，要想解决这个 Bug，可以通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num1 = Integer.parseInt(scanner.next());</span><br></pre></td></tr></table></figure><p>解决。</p><blockquote><p>next() 和 nextLine() 都接收字符串；<br>next() 方法一定要接收到有效字符串才可以结束输入，对输入有效字符之前遇到的空格键、Tab 键或回车键等，next() 方法会自动将其去掉，只有在输入有效字符之后，next() 方法才将其后输入的空格键、Tab 键或回车键视为分隔符或结束符；<br>nextLine() 方法的结束符只是回车键，即 nextLine() 方法返回的是回车键的所有字符。</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://github.com/inspurer/PAT" target="_blank" rel="noopener">PAT Advanced Pratice 题解系列代码集合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h1&gt;&lt;h3 id=&quot;001-A-B-Format-（20-分&quot;&gt;&lt;a href=&quot;#001-A-B-Format-（20-分&quot; class=&quot;headerlink&quot; title=&quot;001 A+B Format （20 分)&quot;&gt;&lt;/a&gt;001 A+B Format （20 分)&lt;/h3&gt;&lt;p&gt;Calculate a+b and output the sum in standard format
    
    </summary>
    
      <category term="PAT" scheme="https://inspurer.github.io/categories/PAT/"/>
    
    
      <category term="PAT" scheme="https://inspurer.github.io/tags/PAT/"/>
    
      <category term="scanner" scheme="https://inspurer.github.io/tags/scanner/"/>
    
  </entry>
  
  <entry>
    <title>利用Tensorflow构建自己的物体识别模型(一)</title>
    <link href="https://inspurer.github.io/2018/12/03/%E5%88%A9%E7%94%A8Tensorflow%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B-%E4%B8%80/"/>
    <id>https://inspurer.github.io/2018/12/03/利用Tensorflow构建自己的物体识别模型-一/</id>
    <published>2018-12-03T15:22:20.000Z</published>
    <updated>2019-03-22T15:48:55.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p>windows10+python3.5+pycharm</p><h2 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h2><p>利用Tensorflow训练搭建自己的物体训练模型，万里长征第一步，先安装tensorflow。<a id="more"></a></p><p>tensorflow分为cpu版和gpu版，gpu版的运行速度是cpu的50倍，但是gpu版的坑太多，要安装许多开发套件,对windows的支持不够友好；更为致命的是,它需要Nvida的中高端显卡，我的电脑系统是windows10,显卡是入门级显卡，开始我还想挣扎一下，安装个gpu版，大概试了一个晚上，到底是没有成功，识时务者为俊杰，那就安装cpu版的吧。</p><blockquote><p>pip insatll tensorflow   </p></blockquote><p>假如没有报错，做个测试，运行以下代码</p><pre><code>import tensorflow as tf#指定一个常数张量first_blood = tf.constant(&apos;double kill&apos;)#创建一个会话，方便查看结果sess = tf.Session()print(str(sess.run(first_blood)))</code></pre><p>运行结果如下</p><pre><code>E:\python\python.exe &quot;E:/pycharm src/TF/__init__.py&quot;2018-12-01 23:33:25.181550: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2double killProcess finished with exit code 0</code></pre><p>如果出现警告:</p><p><code>Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2</code></p><p>翻译过来的大致意思是:<br><code>你的CPU支持AVX扩展，但是你安装的TensorFlow版本无法编译使用</code>   </p><p>此时需要在第一行代码前加上两行代码:</p><pre><code>import osos.environ[&apos;TF_CPP_MIN_LOG_LEVEL&apos;] = &apos;2&apos;import tensorflow as tf# 指定一个常数张量first_blood = tf.constant(&apos;double kill&apos;)# 创建一个会话，方便查看结果sess = tf.Session()print(str(sess.run(first_blood)))</code></pre><h2 id="下载Tensorflow-object-detection-API"><a href="#下载Tensorflow-object-detection-API" class="headerlink" title="下载Tensorflow object detection API"></a>下载Tensorflow object detection API</h2><p>如果有git的话，右键<code>git bash</code>,使用命令下载：</p><blockquote><p>git clone <a href="https://github.com/tensorflow/models.git" target="_blank" rel="noopener">https://github.com/tensorflow/models.git</a>  </p></blockquote><p>或者直接打开网站:</p><blockquote><p><a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a>   </p></blockquote><p>点击绿色按钮-&gt;downlaod zip   </p><p>下载好之后，把文件解压，注意解压路径不要包含中文，比如我的解压后的路径是:</p><blockquote><p>C:\Users\lenovo\Desktop\note\gitclone\models  </p></blockquote><p>如果下载速度很慢，可以参考:<a href="https://blog.csdn.net/ygdxt/article/details/82825013" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/82825013</a></p><h2 id="下载并配置protoc"><a href="#下载并配置protoc" class="headerlink" title="下载并配置protoc"></a>下载并配置protoc</h2><p>在<a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">https://github.com/google/protobuf/releases</a>中选择windows版本：   </p><p><img src="https://i.imgur.com/Zov6Hfk.png" alt=""></p><p>只有win32,也就是windows32位的，64位是兼容32位的。  </p><p>下载好之后，解压，把bin目录下的<code>protoc.exe</code>复制到<code>..\models\research</code>文件夹下。</p><p>接着就是配置protoc了，在打开cmd下切换到<code>..\models\research</code>目录，</p><p>执行命令<code>protoc object_detection\protos\*.proto --python_out=.</code> </p><p>如果报以下的错(其实很大可能性会报错，无论是不是在管理员模式下）：</p><blockquote><p>object_detection\protos*.proto: No such file or directory</p></blockquote><p>则需要对指令做修改，指令<code>protoc object_detection\protos\*.proto --python_out=.</code>中的<code>*.proto</code>表示是对<code>research</code>目录下的所有后缀名为<code>proto</code>的文件做操作，那干脆我们把指令中的<code>*.proto</code>这部分改成所有后缀名为<code>proto</code>的文件，每执行一次，就会生成一个<code>.py</code>文件，由于文件太多，我已经把指令写成脚本:</p><pre><code>import ospath_url = os.path.join(os.getcwd(),r&quot;object_detection\protos&quot;)print(&quot;proto path:&quot;,path_url)for file in os.listdir(path_url):    cmd = &quot;protoc object_detection\protos\{} --python_out=.&quot;    if file.endswith(&quot;.proto&quot;):        command = cmd.format(file)        print(&quot;excuting command:&quot;,command)        os.popen(command)</code></pre><p>在<code>..\research</code>目录下新建一个文件<code>excuter.py</code>,把以上代码复制进去，保存运行，稍等一会儿就可以看到<code>..\research\object_detection\protos</code>目录下生成了许多<code>.py</code>文件，说明protoc配置成功。</p><h2 id="models环境变量配置"><a href="#models环境变量配置" class="headerlink" title="models环境变量配置"></a>models环境变量配置</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>依次打开：<code>我的电脑</code>—&gt;<code>高级系统设置</code>—&gt;<code>环境变量</code>，新建一个系统变量:</p><p><img src="https://i.imgur.com/JijedwT.png" alt=""></p><p><img src="https://i.imgur.com/Xv3LQMO.png" alt=""></p><blockquote><p>系统变量名只要不和已有的重复，符合命令规范，没有其他要求，我这里是<code>tensorflow</code><br>系统变量名下有两个值,<code>..\research</code>和<code>..\research\slim</code>的绝对路径。</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在<code>..\research</code>下打开cmd，运行以下命令，</p><blockquote><p>python object_detection/builders/model_builder_test.py</p></blockquote><p>如果出现错误:  </p><p><img src="https://i.imgur.com/asuh01x.png" alt=""></p><p>报错原因是你的models路径太长，python无法找指定模块，<br>解决办法是在你的<code>python</code>安装路径下新建一个<code>tensorflow_model.pth</code>文件<br>(比如我的是<code>E:\python\Lib\site-packages</code>)<br>把写到环境变量里的那两个路径复制到该文件中。<br><img src="https://i.imgur.com/ttKY474.png" alt=""></p><p>再运行命令<code>python object_detection/builders/model_builder_test.py</code><br><img src="https://i.imgur.com/ILr2wSV.png" alt=""></p><p>说明配置成功</p><h2 id="利用tensorflow自带模型测试"><a href="#利用tensorflow自带模型测试" class="headerlink" title="利用tensorflow自带模型测试"></a>利用tensorflow自带模型测试</h2><p>测试的图片是在</p><blockquote><p><code>C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\test_images</code>  </p></blockquote><p>我们看到这里有现成的两张图片，当然也可以换成自己的。</p><p>测试的脚本是</p><blockquote><p>C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\object_detection_tutorial.ipynb  </p></blockquote><p>这是一个需要用<code>jupyter notebook</code>打开的文件，不过好像在<code>jupyter notebook</code>运行会有许多毛病<br>我已经把这个<code>ipynb</code>文件改写成<code>py</code>文件，并修复了一些未知问题，文件内容如下:</p><pre><code>import numpy as npimport osimport six.moves.urllib as urllibimport sysimport tarfileimport tensorflow as tfimport zipfilefrom distutils.version import StrictVersionfrom collections import defaultdictfrom io import StringIOfrom matplotlib import pyplot as pltfrom PIL import Image# This is needed since the notebook is stored in the object_detection folder.sys.path.append(&quot;..&quot;)from object_detection.utils import ops as utils_opsif StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;):  raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;)import numpy as npimport osimport six.moves.urllib as urllibimport sysimport tarfileimport tensorflow as tfimport zipfilefrom distutils.version import StrictVersionfrom collections import defaultdictfrom io import StringIOfrom matplotlib import pyplot as pltfrom PIL import Image# This is needed since the notebook is stored in the object_detection folder.sys.path.append(&quot;..&quot;)from object_detection.utils import ops as utils_opsif StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;):  raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;)from utils import label_map_utilfrom utils import visualization_utils as vis_util# What model to download.MODEL_NAME = &apos;ssd_mobilenet_v1_coco_2017_11_17&apos;MODEL_FILE = MODEL_NAME + &apos;.tar.gz&apos;DOWNLOAD_BASE = &apos;http://download.tensorflow.org/models/object_detection/&apos;# Path to frozen detection graph. This is the actual model that is used for the object detection.PATH_TO_FROZEN_GRAPH = MODEL_NAME + &apos;/frozen_inference_graph.pb&apos;# List of the strings that is used to add correct label for each box.PATH_TO_LABELS = os.path.join(&apos;data&apos;, &apos;mscoco_label_map.pbtxt&apos;)opener = urllib.request.URLopener()opener.retrieve(DOWNLOAD_BASE + MODEL_FILE, MODEL_FILE)tar_file = tarfile.open(MODEL_FILE)for file in tar_file.getmembers():  file_name = os.path.basename(file.name)  if &apos;frozen_inference_graph.pb&apos; in file_name:    tar_file.extract(file, os.getcwd())detection_graph = tf.Graph()with detection_graph.as_default():  od_graph_def = tf.GraphDef()  with tf.gfile.GFile(PATH_TO_FROZEN_GRAPH, &apos;rb&apos;) as fid:    serialized_graph = fid.read()    od_graph_def.ParseFromString(serialized_graph)    tf.import_graph_def(od_graph_def, name=&apos;&apos;)category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS, use_display_name=True)def load_image_into_numpy_array(image):  (im_width, im_height) = image.size  return np.array(image.getdata()).reshape(      (im_height, im_width, 3)).astype(np.uint8)# For the sake of simplicity we will use only 2 images:# image1.jpg# image2.jpg# If you want to test the code with your images, just add path to the images to the TEST_IMAGE_PATHS.PATH_TO_TEST_IMAGES_DIR = &apos;test_images&apos;TEST_IMAGE_PATHS = [ os.path.join(PATH_TO_TEST_IMAGES_DIR, &apos;image{}.jpg&apos;.format(i)) for i in range(1, 3) ]# Size, in inches, of the output images.IMAGE_SIZE = (12, 8)output_num = 1output_img_dic = r&apos;\output_images&apos;def run_inference_for_single_image(image, graph):  with graph.as_default():    with tf.Session() as sess:      # Get handles to input and output tensors      ops = tf.get_default_graph().get_operations()      all_tensor_names = {output.name for op in ops for output in op.outputs}      tensor_dict = {}      for key in [          &apos;num_detections&apos;, &apos;detection_boxes&apos;, &apos;detection_scores&apos;,          &apos;detection_classes&apos;, &apos;detection_masks&apos;      ]:        tensor_name = key + &apos;:0&apos;        if tensor_name in all_tensor_names:          tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(              tensor_name)      if &apos;detection_masks&apos; in tensor_dict:        # The following processing is only for single image        detection_boxes = tf.squeeze(tensor_dict[&apos;detection_boxes&apos;], [0])        detection_masks = tf.squeeze(tensor_dict[&apos;detection_masks&apos;], [0])        # Reframe is required to translate mask from box coordinates to image coordinates and fit the image size.        real_num_detection = tf.cast(tensor_dict[&apos;num_detections&apos;][0], tf.int32)        detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1])        detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1])        detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks(            detection_masks, detection_boxes, image.shape[0], image.shape[1])        detection_masks_reframed = tf.cast(            tf.greater(detection_masks_reframed, 0.5), tf.uint8)        # Follow the convention by adding back the batch dimension        tensor_dict[&apos;detection_masks&apos;] = tf.expand_dims(            detection_masks_reframed, 0)      image_tensor = tf.get_default_graph().get_tensor_by_name(&apos;image_tensor:0&apos;)      # Run inference      output_dict = sess.run(tensor_dict,                             feed_dict={image_tensor: np.expand_dims(image, 0)})      # all outputs are float32 numpy arrays, so convert types as appropriate      output_dict[&apos;num_detections&apos;] = int(output_dict[&apos;num_detections&apos;][0])      output_dict[&apos;detection_classes&apos;] = output_dict[          &apos;detection_classes&apos;][0].astype(np.uint8)      output_dict[&apos;detection_boxes&apos;] = output_dict[&apos;detection_boxes&apos;][0]      output_dict[&apos;detection_scores&apos;] = output_dict[&apos;detection_scores&apos;][0]      if &apos;detection_masks&apos; in output_dict:        output_dict[&apos;detection_masks&apos;] = output_dict[&apos;detection_masks&apos;][0]  return output_dictfor image_path in TEST_IMAGE_PATHS:  image = Image.open(image_path)  # the array based representation of the image will be used later in order to prepare the  # result image with boxes and labels on it.  image_np = load_image_into_numpy_array(image)  # Expand dimensions since the model expects images to have shape: [1, None, None, 3]  image_np_expanded = np.expand_dims(image_np, axis=0)  # Actual detection.  output_dict = run_inference_for_single_image(image_np, detection_graph)  # Visualization of the results of a detection.  vis_util.visualize_boxes_and_labels_on_image_array(      image_np,      output_dict[&apos;detection_boxes&apos;],      output_dict[&apos;detection_classes&apos;],      output_dict[&apos;detection_scores&apos;],      category_index,      instance_masks=output_dict.get(&apos;detection_masks&apos;),      use_normalized_coordinates=True,      line_thickness=8)  plt.figure(figsize=IMAGE_SIZE)  print(1,image_np)  plt.imshow(image_np)  plt.show()  global output_num  global output_img_dic  if not os.path.exists(output_img_dic):      os.mkdir(output_img_dic)  output_img_path = os.path.join(output_img_dic,str(output_num)+&quot;.png&quot;)  plt.savefig(output_img_path)</code></pre><blockquote><p>运行上述代码需要安装<code>matplotlib</code>库，直接<code>pip install matplotlib</code>安装失败的可以去官网安装与python版本对应的whl文件。安装<code>matplotlib.whl</code>时需要先出pycharm。<br>同时由于需要下载模型文件，需要在网络好的情况下进行测试。否则就会报<code>HTTP ERROR</code></p></blockquote><h2 id="运行效果图"><a href="#运行效果图" class="headerlink" title="运行效果图"></a>运行效果图</h2><p><img src="https://i.imgur.com/JuKrvQ9.png" alt=""><br><img src="https://i.imgur.com/me6S453.png" alt=""></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>以上就是本次教程的所有内容，后续还会有系列教程，原创作品，转载请联系<a href="mailto:2391527690@qq.com" target="_blank" rel="noopener">2391527690@qq.com</a><br>欢迎大家多多上机操作，指出本教程的不足之处，如有问题，可加群交流，群号码: 861016679<br>本文首发于<a href="https://www.jianshu.com/p/9c9b908a2b73" target="_blank" rel="noopener">我的简书</a>，如果您在本站上看到了google广告，请多多点击，算是对我的一个鼓励，能够赞赏那就更好了，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原料&quot;&gt;&lt;a href=&quot;#原料&quot; class=&quot;headerlink&quot; title=&quot;原料&quot;&gt;&lt;/a&gt;原料&lt;/h2&gt;&lt;p&gt;windows10+python3.5+pycharm&lt;/p&gt;
&lt;h2 id=&quot;安装tensorflow&quot;&gt;&lt;a href=&quot;#安装tensorflow&quot; class=&quot;headerlink&quot; title=&quot;安装tensorflow&quot;&gt;&lt;/a&gt;安装tensorflow&lt;/h2&gt;&lt;p&gt;利用Tensorflow训练搭建自己的物体训练模型，万里长征第一步，先安装tensorflow。
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="tensorflow" scheme="https://inspurer.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>一文搞定python的时间处理</title>
    <link href="https://inspurer.github.io/2018/12/03/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Apython%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    <id>https://inspurer.github.io/2018/12/03/一文搞定python的时间处理/</id>
    <published>2018-12-03T15:17:58.000Z</published>
    <updated>2018-12-03T15:21:11.830Z</updated>
    
    <content type="html"><![CDATA[<p>如果认真看完这篇文章你还不知道怎么处理python的时间问题，你可以来diss我<a id="more"></a></p><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><pre><code># -*- coding: utf-8 -*-# author:           inpurer(月小水长)# pc_type           lenovo# create_date:      2018/12/3# file_name:        timetest.py# description:      月小水长，热血未凉import timet0 = time.time()#description:   输出当前时间距离1970.1.1的秒数,精确到小数点后6位，也叫做时间戳#output sample: 1543799532.602318print(t0)t1 = time.localtime(t0)#description:   把时间戳转成元组,包含七个元素,前六个见名知意,tm_wday是指今天是当前周的第几天(index from 0),tm_yday类似,tm_isdst是否是夏令时,不用关心#output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=22, tm_sec=24, tm_wday=0, tm_yday=337, tm_isdst=0)print(t1)#so,可以这样输出今天是今年的第多少天print(t1[-2]+1)#下面是对该元组的格式化#description:   简单可读形式#output sample: Mon Dec  3 09:31:18 2018t2 = time.asctime(t1)print(t2)#description:   可通过参数设置成各种形式，下面是一种标准形式,各参数见名知意#output sample: 2018-12-03 09:33:36t3 = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t1)print(t3)#%y 两位数的年份表示（00-99）# %Y 四位数的年份表示（000-9999）# %m 月份（01-12）# %d 月内中的一天（0-31）# %H 24小时制小时数（0-23）# %I 12小时制小时数（01-12）# %M 分钟数（00=59）# %S 秒（00-59）## %a 本地简化星期名称# %A 本地完整星期名称# %b 本地简化的月份名称# %B 本地完整的月份名称# %c 本地相应的日期表示和时间表示# %j 年内的一天（001-366）# %p 本地A.M.或P.M.的等价符# %U 一年中的星期数（00-53）星期天为星期的开始# %w 星期（0-6），星期天为星期的开始# %W 一年中的星期数（00-53）星期一为星期的开始# %x 本地相应的日期表示# %X 本地相应的时间表示# %Z 当前时区的名称# %% %号本身# 下面是把格式化字符串转成元组# description:      第一个参数个格式化后的字符串,后一个参数和格式化对应，便于反格式化# output sample:    time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=47, tm_sec=7, tm_wday=0, tm_yday=337, tm_isdst=-1)t4 = time.strptime(t3,&apos;%Y-%m-%d %H:%M:%S&apos;)print(t4)# 把元组转成时间戳#description:   是time.localtime的反函数,不过由于格式化的原因，精度有所下降#output sample: 1543801627.0t5 = time.mktime(t4)print(t5)</code></pre><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><pre><code># -*- coding: utf-8 -*-# author:           inpurer(月小水长)# pc_type           lenovo# create_date:      2018/12/3# file_name:        timetest.py# description:      月小水长，热血未凉import datetime#通过datetime.datetime.now()可以获得当前日期时间的一个实例#这个实例是一个datetime类对象而不是字符串#虽然直接打印该实例输出的是一个字符串,只是调用datetime实现的__str__方法而已t0 = datetime.datetime.now()print(t0)           #print: 2018-12-03 12:55:49.905971print(type(t0))     #print: &lt;class &apos;datetime.datetime&apos;&gt;#然后就可以通过对象名.的方法输出各个时间信息,该信息是一个int类型print(t0.year)          #print: 2018print(type(t0.year))    #print: &lt;class &apos;int&apos;&gt;print(t0.month)print(t0.day)print(t0.hour)print(t0.minute)print(t0.second)</code></pre><h2 id="时间的存储，比较"><a href="#时间的存储，比较" class="headerlink" title="时间的存储，比较"></a>时间的存储，比较</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>理论上我们可以通过拼接datetime.datetime.now()实例的各个时间变量来构建我们自己的想要时间,例如我们想要存储<code>year-month-day</code>这样的时间信息，我们可以这样做:</p><pre><code>import datetimet0 = datetime.datetime.now()#注意year/month/day都是int类型，不像java那样可以直接拼接字符串和数字wanted_time = str(t0.year)+&quot;-&quot;+str(t0.month)+&quot;-&quot;+str(t0.day)</code></pre><p>但是，这样做会有非常尴尬的问题:格式不统一，可能会出现下面这样的存储形式：  </p><blockquote><p>2018-1-1<br>2018-1-11<br>2018-11-1<br>2018-11-11<br>……………..  </p></blockquote><p>特别是在数据量非常庞大的时候，阅读起来非常费力，这是因为year/month/day这些都是int型，所以<code>1</code>就是<code>1</code>，不会显示成<code>01</code>,要实现对齐效果，必须还得字符串的格式化，所以，我们通常用的是time模块(其实datetime也有字符串的格式化，不过展开讲就太多了，不必要浪费这么多学习成本)</p><pre><code>import timet0 = time.localtime()wanted_time = time.strftime(&quot;%Y-%m-%d&quot;,t0)</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>就拿上面刚刚说的<code>wanted_time</code>来说，可以直接通过<code>&gt;</code>、<code>=</code>、<code>&lt;</code>这些符号来比较，因为<code>wanted_time</code>就是一个字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果认真看完这篇文章你还不知道怎么处理python的时间问题，你可以来diss我
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="time" scheme="https://inspurer.github.io/tags/time/"/>
    
      <category term="datetime" scheme="https://inspurer.github.io/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>Python实现微信自动回复和群聊助手</title>
    <link href="https://inspurer.github.io/2018/12/01/Python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%92%8C%E7%BE%A4%E8%81%8A%E5%8A%A9%E6%89%8B/"/>
    <id>https://inspurer.github.io/2018/12/01/Python实现微信自动回复和群聊助手/</id>
    <published>2018-12-01T01:45:02.000Z</published>
    <updated>2019-03-22T15:46:55.875Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的简书<a href="https://www.jianshu.com/p/4b7b4f4fb0e4" target="_blank" rel="noopener">https://www.jianshu.com/p/4b7b4f4fb0e4</a><a id="more"></a></p><h1 id="本教程的作用"><a href="#本教程的作用" class="headerlink" title="本教程的作用"></a>本教程的作用</h1><p>零基础手把手教你打造一款微信机器人，包括好友聊天自动回复和群聊助手两个部分，零基础！话不多说，下面开始实战编码。</p><h1 id="第一部分-好友聊天自动回复"><a href="#第一部分-好友聊天自动回复" class="headerlink" title="第一部分:好友聊天自动回复"></a>第一部分:好友聊天自动回复</h1><h2 id="第一步，安装python环境。"><a href="#第一步，安装python环境。" class="headerlink" title="第一步，安装python环境。"></a>第一步，安装python环境。</h2><p>打开python官网<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a>，下载与你的电脑系统相匹配的python发行版本，推荐python3.5-python3.6,版本太高了可能有许多未知的bug，太低了兼容性不太好。</p><h2 id="第二步，安装itchat库"><a href="#第二步，安装itchat库" class="headerlink" title="第二步，安装itchat库"></a>第二步，安装itchat库</h2><p>在命令行下输入<code>pip install itchat</code>完成安装   </p><h2 id="第三步，编写代码"><a href="#第三步，编写代码" class="headerlink" title="第三步，编写代码"></a>第三步，编写代码</h2><p>核心代码如下：</p><pre><code>  #coding=utf8import itchat# 当接收到的消息是Text，即文字消息#注册re_msg的意义在于，告诉itchat每次有符合特定条件的消息，itchat要把消息作为参数，去调用re_msg。@itchat.msg_register(&apos;Text&apos;)def text_reply(msg):    #message:取出msg里面的文本消息    message = msg[&apos;Text&apos;]    # 回复给好友    replay = u&apos;肖涛已在电脑上登陆网页微信，但暂时无法进行交流,可以给他发送电脑QQ消息哈&apos;      #主要是一些关键词设置    # if B in A 如果 A中有B的话    if u&apos;干什么&apos; in message:        replay = u&apos;在忙呢&apos;    elif u&apos;逼&apos; in message:        replay = u&apos;含有敏感词汇,请注意言辞&apos;    elif u&apos;生气&apos; in message:        replay = u&apos;生气对身体不好&apos;    elif u&apos;?&apos; in  message:        replay = u&apos;哈哈，我也不知道&apos;    elif u&apos;不理你&apos; in message:        replay = u&apos;乖，忙完给你买糖吃&apos;    elif u&apos;涛&apos; in message:        replay = u&apos;他是我主人&apos;    elif u&apos;厉害&apos; in message:        replay = u&apos;不不不，辣鸡一个&apos;    elif u&apos;你好&apos; in message:        replay = u&apos;你好哇&apos;    elif u&apos;好吧&apos; in message:        replay = u&apos;再见&apos;    return replay#弹出扫码登录界面,参数这样设置的好处是短时间内退出程序，再次登录可以不用扫码itchat.auto_login(hotReload=True)#开启自动回复itchat.run()</code></pre><p>以上代码都是本人亲自编写，如需转载请私信我。<br>代码截至2018/11/30本人调试有效，最新的代码更新在我的github：<a href="https://github.com/inspurer/PythonLearning/blob/master/python%E5%B0%8F%E9%A1%B9%E7%9B%AE/itchat_wechat/auto_replay.py" target="_blank" rel="noopener">auto_replay.py</a>如有问题欢迎评论。</p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>运行之后，会弹出一个二维码，用微信扫一扫登录网页版微信之后，这份代码就会接管你的消息通知。下面是一个简单的效果图<br><img src="https://upload-images.jianshu.io/upload_images/13236872-034194b9a0fe532b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20180331100337372.png"></p><h1 id="第二部分：群聊助手"><a href="#第二部分：群聊助手" class="headerlink" title="第二部分：群聊助手"></a>第二部分：群聊助手</h1><p>第一步是点对点的消息自动回复，本部分实现的是点对多、在群中的消息自动回复。请确认上一部分实现无误之后再来尝试第二部分，因为第二部分需要第一部分的环境配置做支撑。</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><pre><code>  import itchatimport requestsdef get_response(msg):    apiUrl = &apos;http://www.tuling123.com/openapi/api&apos;   #改成你自己的图灵机器人的api        &apos;key&apos;: &apos;ce697b3fc8b54d5f88c2fa59772cb2cf&apos;,  # Tuling Key         &apos;info&apos;: msg,  # 这是我们发出去的消息        &apos;userid&apos;: &apos;wechat-robot&apos;,  # 这里可随意修改    }    # 通过如下命令发送一个post请求    r = requests.post(apiUrl, data=data).json()    return r.get(&apos;text&apos;)@itchat.msg_register(itchat.content.TEXT)#用于接收来自朋友间的对话消息  #如果不用这个，朋友发的消息便不会自动回复 def print_content(msg):    return get_response(msg[&apos;Text&apos;])#用于接收群里面的对话消息@itchat.msg_register([itchat.content.TEXT], isGroupChat=True)def print_content(msg):    return get_response(msg[&apos;Text&apos;])itchat.auto_login(True)itchat.run()</code></pre><h2 id="接入图灵机器人"><a href="#接入图灵机器人" class="headerlink" title="接入图灵机器人"></a>接入图灵机器人</h2><p>打卡图灵机器人官网，<a href="http://www.tuling123.com/" target="_blank" rel="noopener">http://www.tuling123.com/</a>,注册账号，新建一个机器人，如下图<br><img src="https://upload-images.jianshu.io/upload_images/13236872-e6ca6877df235781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20180718175512463.png"><br>把图中的apikey替换到代码里就行，如果你要用我的，我也无法拒绝，毕竟我的apikey也贴出来了。</p><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://upload-images.jianshu.io/upload_images/13236872-c4c3a65b233be1cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和上一个效果图不同的是，这是在一个群里的消息"></p><h2 id="简要原理"><a href="#简要原理" class="headerlink" title="简要原理"></a>简要原理</h2><p>一但接收到信息，就会调用get_response()方法，把消息传给图灵机器人，然后图灵机器人把回复信息再返回给微信。</p><p>截至2018/11/30代码运行无误，最新更新在我的github：<a href="https://github.com/inspurer/PythonLearning/blob/master/python%E5%B0%8F%E9%A1%B9%E7%9B%AE/itchat_wechat/grouphandler.py" target="_blank" rel="noopener">grouphandler.py</a><br>如有问题请评论，如需转载请私信我。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本篇文章参考了我的两篇csdn博客<br><a href="https://blog.csdn.net/ygdxt/article/details/79766197" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/79766197</a><br><a href="https://blog.csdn.net/ygdxt/article/details/81101020" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/81101020</a><br>在这里推荐两个python代码仓库：<br>一个是<a href="https://github.com/inspurer/PythonLearning" target="_blank" rel="noopener">PythonLearning</a>,这里面有我学习python的课程学习资料、以及一些我实战编写的代码，<br>另一个是<a href="https://github.com/inspurer/PythonSpider" target="_blank" rel="noopener">PythonSpider</a>,这里面主要是一些我写的python实现的爬虫。<br>更多的请访问我的github，欢迎star，fork.<br>另外欢迎关注微信公众号：inspurer</p><p>如果你觉得本篇文章不错，不妨打赏一下，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的简书&lt;a href=&quot;https://www.jianshu.com/p/4b7b4f4fb0e4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/4b7b4f4fb0e4&lt;/a&gt;
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="itchat" scheme="https://inspurer.github.io/tags/itchat/"/>
    
  </entry>
  
  <entry>
    <title>python爬取学校教务系统</title>
    <link href="https://inspurer.github.io/2018/11/30/python%E7%88%AC%E5%8F%96%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://inspurer.github.io/2018/11/30/python爬取学校教务系统/</id>
    <published>2018-11-30T05:58:53.000Z</published>
    <updated>2019-03-22T15:46:40.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写这个爬虫的缘由"><a href="#写这个爬虫的缘由" class="headerlink" title="写这个爬虫的缘由"></a>写这个爬虫的缘由</h1><p>以前用java写过一个爬取学校的教务系统的爬虫 <a href="https://blog.csdn.net/ygdxt/article/details/81158321" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/81158321</a>，最近痴迷Python爬虫，了解到许多强大的库，想再一次用学校的教务系统做下测试。<br><a id="more"></a><br>这一次我首先想到的是新的教务系统，这个难度更大，因为有了验证码识别反爬，由于我是用的tessocr库识别验证码,(具体配置过程可以参考我之前的博客<a href="https://blog.csdn.net/ygdxt/article/details/83793746" target="_blank" rel="noopener">    python填坑之路:tesserocr配置</a>)<br>用Requests.get方法把验证码下载下来识别之后，同时因为我爬取网页是用的selenium做的模拟网页动作，这里就有一个同步性的问题，不能保证selenium请求网页上的验证码和requests请求的验证码是同一个，相当于selenium、requests分别请求了一次登陆网页，两个网页上的验证码显然是不同的。所以</p><pre><code>怎么保证请求登录界面得到的网页上的验证码和我们请求验证码服务器返回的验证码是同一个验证码是同一个是一个很迷人的问题，我开始还以为可以从网页源代码上直接定位到这个验证码，结果显示这个验证码在登录界面的  的存在形式不是一个..png/jpg,而是通过src=“验证码服务器”来实现异步加载</code></pre><p>同时，由于tessocr识别验证码的成功率可能只有50%，要提高验证率可能还要对接云打码，果断放弃了爬取新教务系统的想法，还是爬取原来的没有验证码的旧教务系统，<br>其实新旧教务系统最大的区别就是登陆界面不一样，登陆之后都一样，貌似用了重定向<br>ps:如果你对这个问题有什么好的解决办法，请不吝赐教</p><h1 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h1><p>详细的代码解释就看注释吧，有什么问题欢迎交流</p><h2 id="执行爬虫的主程序csu-py，里面有许多测试用的注释代码，就不删了"><a href="#执行爬虫的主程序csu-py，里面有许多测试用的注释代码，就不删了" class="headerlink" title="执行爬虫的主程序csu.py，里面有许多测试用的注释代码，就不删了"></a>执行爬虫的主程序<code>csu.py</code>，里面有许多测试用的注释代码，就不删了</h2><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.select import Selectfrom config import *import timebroswer = webdriver.Chrome()wait = WebDriverWait(broswer, 10)def search():    try:        broswer.get(&quot;http://csujwc.its.csu.edu.cn/jsxsd/kscj/yscjcx_list&quot;)        account = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userAccount&quot;))        )        password = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userPassword&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#btnSubmit&quot;))        )    except TimeoutException:        return search()    #登录    account.send_keys(ACCOUNT)    password.send_keys(PASSWORD)    submit.click()   #进入我的成绩界面    my_score = wait.until(        EC.presence_of_element_located((By.CSS_SELECTOR,&quot;body &gt; div.wap &gt; a:nth-child(3) &gt; div&quot;))    )    my_score.click()#成绩和平均分    # my_rank = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(4) &gt; a&quot;))    # )    # my_rank.click()    #    # rank = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(3)&quot;))    # )    # #http://www.w3school.com.cn/cssref/selector_nth-child.asp nth-child(n)的用法    # average_score = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(4)&quot;))    # )    #    # print(&apos;您的平均成绩是:&apos;+average_score.text+&quot;\n排名:&quot;+rank.text)#逐次展示 我的成绩八个子项    # css_selector = &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child({0}) &gt; a&quot;    # for i in range(8):    #     # 将滚动条移动到页面的顶部    #     js = &quot;var q=document.documentElement.scrollTop=0&quot;    #     broswer.execute_script(js)    #     time.sleep(2)    #    #     aviable_score = wait.until(    #         EC.presence_of_element_located((By.CSS_SELECTOR, css_selector.format(str(i+1))))    #     )    #     aviable_score.click()    #    #    #     #将滚动条移动到页面的底部    #     for j in range(8):    #         js=&quot;var q=document.documentElement.scrollTop=&quot;+str(j*200)    #         broswer.execute_script(js)    #         time.sleep(1)    #处理select https://www.cnblogs.com/imyalost/p/7846653.html    yxcj = wait.until(        EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(1) &gt; a&quot;))    )    select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;)    select_score = Select(select_score_element)    #得到下拉列表的所有子项    select_score_items = broswer.find_elements_by_css_selector(&quot;#xnxq01id option&quot;)    select_score_items_text = []    for item in select_score_items:        select_score_items_text.append(item.text)        #print(item.text)    scores_dic = {}    for i in range(len(select_score.options)):        #不加这两行会报错，原因： https://blog.csdn.net/ulebo/article/details/52128033        print(&quot;*****************************************************&quot;+select_score_items_text[i]+              &quot;*****************************************************&quot;)        select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;)        select_score = Select(select_score_element)        select_score.select_by_index(i)        time.sleep(1)        score_table = broswer.find_element_by_css_selector(&quot;#dataList&quot;)        data = score_table.text.replace(&quot;+&quot;,&quot;&quot;)        data = data.split(&quot;\n&quot;)        datalist = []        for line in data:            datalist.append(line.split())        scores_dic[select_score_items_text[i]] = datalist    return scores_dic[select_score_items_text[0]]def main():    search()if __name__ ==&quot;__main__&quot;:    main()</code></pre><h2 id="ui-py程序的gui，直接运行这个就好，它会调用csu-py"><a href="#ui-py程序的gui，直接运行这个就好，它会调用csu-py" class="headerlink" title="ui.py程序的gui，直接运行这个就好，它会调用csu.py"></a><code>ui.py</code>程序的gui，直接运行这个就好，它会调用<code>csu.py</code></h2><pre><code>    #coding=utf-8import wximport wx.gridimport csuclass UI(wx.Frame):    def __init__(self):        wx.Frame.__init__(self,parent=None,title=&quot;成绩查询&quot;,size=(1050,560))        grid = wx.grid.Grid(self,pos=(10,0),size=(1050,500))        grid.CreateGrid(100,9)        for i in range(100):            for j in range(9):                grid.SetCellAlignment(i,j,wx.ALIGN_CENTER,wx.ALIGN_CENTER)        grid.SetColLabelValue(0, &quot;序号&quot;) #第一列标签        grid.SetColLabelValue(1, &quot;初修学期&quot;)        grid.SetColLabelValue(2, &quot;获得学期&quot;)        grid.SetColLabelValue(3, &quot;课程&quot;)        grid.SetColLabelValue(4, &quot;成绩&quot;)  # 第一列标签        grid.SetColLabelValue(5, &quot;学分&quot;)        grid.SetColLabelValue(6, &quot;课程属性&quot;)        grid.SetColLabelValue(7, &quot;课程性质&quot;)        grid.SetColLabelValue(8, &quot;获得方式&quot;)  # 第一列标签        grid.SetColSize(0,50)        grid.SetColSize(1,100)        grid.SetColSize(2,100)        grid.SetColSize(3,350)        grid.SetColSize(4,50)        grid.SetColSize(5,50)        grid.SetColSize(6,50)        grid.SetColSize(7,100)        grid.SetColSize(8,100)        grid.SetCellTextColour(&quot;NAVY&quot;)        data = csu.search()        data.remove(data[0])        print(data)        for i,item1 in enumerate(data):            for j,item2 in enumerate(item1):                grid.SetCellValue(i,j,data[i][j])        passapp = wx.App()frame = UI()frame.Show()app.MainLoop()</code></pre><h2 id="想要运行代码，具体的配置过程请参考readme"><a href="#想要运行代码，具体的配置过程请参考readme" class="headerlink" title="想要运行代码，具体的配置过程请参考readme"></a>想要运行代码，具体的配置过程请参考<a href="https://github.com/inspurer/PythonSpider/blob/master/csu/readme.md" target="_blank" rel="noopener">readme</a></h2><h2 id="运行结果预览"><a href="#运行结果预览" class="headerlink" title="运行结果预览"></a>运行结果预览</h2><p><img src="https://i.imgur.com/z2e9hWN.png" alt=""><br>如图片不可加载，请点击<a href="https://blog.csdn.net/ygdxt/article/details/84591649" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/84591649</a></p><h1 id="源代码地址https-github-com-inspurer-PythonSpider-tree-master-csu"><a href="#源代码地址https-github-com-inspurer-PythonSpider-tree-master-csu" class="headerlink" title="源代码地址https://github.com/inspurer/PythonSpider/tree/master/csu"></a>源代码地址<a href="https://github.com/inspurer/PythonSpider/tree/master/csu" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/csu</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写这个爬虫的缘由&quot;&gt;&lt;a href=&quot;#写这个爬虫的缘由&quot; class=&quot;headerlink&quot; title=&quot;写这个爬虫的缘由&quot;&gt;&lt;/a&gt;写这个爬虫的缘由&lt;/h1&gt;&lt;p&gt;以前用java写过一个爬取学校的教务系统的爬虫 &lt;a href=&quot;https://blog.csdn.net/ygdxt/article/details/81158321&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ygdxt/article/details/81158321&lt;/a&gt;，最近痴迷Python爬虫，了解到许多强大的库，想再一次用学校的教务系统做下测试。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python爬取b站视频</title>
    <link href="https://inspurer.github.io/2018/11/25/python%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <id>https://inspurer.github.io/2018/11/25/python爬取b站视频/</id>
    <published>2018-11-25T11:46:01.000Z</published>
    <updated>2019-03-22T15:47:16.802Z</updated>
    
    <content type="html"><![CDATA[<p>python爬虫系列：<br>上一篇<br><a href="https://inspurer.github.io/2018/11/14/python%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93/#more">python爬取图虫网图库</a><br>今天突然来了兴趣想要爬取下载b站视频，话不多说，说干就干。<a id="more"></a></p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><h1 id="下载仓库"><a href="#下载仓库" class="headerlink" title="下载仓库"></a>下载仓库</h1><pre><code>git@github.com:inspurer/PythonSpider.git </code></pre><p>或者直接下载:<a href="https://github.com/inspurer/PythonSpider/tree/master/bilibili" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/bilibili</a>   </p><h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><p>随便打开一个b站的界面，比如<br><img src="https://img-blog.csdnimg.cn/20181125182030407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lnZHh0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">将url复制到代码中去，运行代码，稍等一会儿，上述图中的视频就被下载下来了。  </p><h1 id="How-to-Code"><a href="#How-to-Code" class="headerlink" title="How to Code"></a>How to Code</h1><h2 id="分析网页源码"><a href="#分析网页源码" class="headerlink" title="分析网页源码"></a>分析网页源码</h2><p>按f12浏览器开发者工具 ，通过一番审查，我们定位到视频的url在网页源代码的位置如下：   </p><pre><code>window.__playinfo__={&quot;from&quot;:&quot;local&quot;,&quot;result&quot;:&quot;suee&quot;,&quot;quality&quot;:32,&quot;format&quot;:&quot;flv480&quot;,&quot;timelength&quot;:408884,&quot;accept_format&quot;:&quot;flv720,flv480,flv360&quot;,&quot;accept_description&quot;:[&quot;高清 720P&quot;,&quot;清晰 480P&quot;,&quot;流畅 360P&quot;],&quot;accept_quality&quot;:[64,32,15],&quot;video_codecid&quot;:7,&quot;video_project&quot;:true,&quot;seek_param&quot;:&quot;start&quot;,&quot;seek_type&quot;:&quot;offset&quot;,&quot;durl&quot;:[{&quot;order&quot;:1,&quot;length&quot;:408884,&quot;size&quot;:42782550,&quot;ahead&quot;:&quot;EhA=&quot;,&quot;vhead&quot;:&quot;AWQAHv/hAB5nZAAerNlA2D3n//AoACfxAAADAAEAAAMAMA8WLZYBAAVo6+zyPA==&quot;,&quot;url&quot;:&quot;http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345&quot;,&quot;backup_url&quot;:[&quot;http://upos-hz-mirrorcos.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?um_deadline=1543136253&amp;platform=pc&amp;rate=176800&amp;oi=1862807981&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;gen=playurl&amp;os=cos&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&quot;]}]}</code></pre><p>最后的url就是我们想要的结果。<br>如果在浏览器中查找不方便的话，我们可以把通过代码把网页源码输出到本地    </p><pre><code>response = requests.get(url=&apos;https://www.bilibili.com/video/av26522634&apos;, headers= self.getHtmlHeaders)        print(response.status_code)        if response.status_code == 200:            print(response.text)</code></pre><p>为了伪装成浏览器，我们需要在reqests添加Headers<br>这个Headers需要我们去浏览器中手动获取<br>切换到NetWork标签下，再选择Headers，<br><img src="https://img-blog.csdnimg.cn/20181125183539318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lnZHh0,size_16,color_FFFFFF,t_70" alt="如图片显示有问题请到csdn观看"></p><pre><code>self.getHtmlHeaders={     &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,     &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,     &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,     &apos;Accept-Language&apos;: &apos;zh-CN,zh;q = 0.9&apos; }</code></pre><p>  这里只选择了几个关键的</p><h2 id="解析得到视频地址"><a href="#解析得到视频地址" class="headerlink" title="解析得到视频地址"></a>解析得到视频地址</h2><p>根据上一步分析，我们得到了网页的源码，并在源码中定位到了视频地址，接下来，我们就用代码自动获取这个地址了</p><pre><code>#用正则、json得到视频url;用pq失败后的无奈之举pattern = r&apos;\&lt;script\&gt;window\.__playinfo__=(.*?)\&lt;/script\&gt;&apos;result = re.findall(pattern, html)[0]temp = json.loads(result)#temp[&apos;durl&apos;]是一个列表，里面有很多字典#video_url = temp[&apos;durl&apos;]for item in temp[&apos;durl&apos;]:    if &apos;url&apos; in item.keys():        video_url = item[&apos;url&apos;]</code></pre><p>顺便获取下视频的名字：</p><pre><code>#用pq解析得到视频标题doc = pq(html)video_title = doc(&apos;#viewbox_report &gt; h1 &gt; span&apos;).text()</code></pre><p>然后组合返回下：</p><pre><code>return{ &apos;title&apos;: video_title, &apos;url&apos;: video_url }</code></pre><h2 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h2><p>通过在开发者工具中搜索关键词，比如上面得到的视频url，我们可以定位到在浏览器中真正下载视频的请求在哪<br><img src="https://img-blog.csdnimg.cn/20181125184744803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lnZHh0,size_16,color_FFFFFF,t_70" alt="如图片显示有问题请到csdn观看">然后把它的Headers添加到reqests中，就可以下载视频了  </p><pre><code>with open(filename, &quot;wb&quot;) as f:     f.write(requests.get(url=url, headers=self.downloadVideoHeaders, stream=True, verify=False).content)</code></pre><h1 id="愉快地观看本地视频"><a href="#愉快地观看本地视频" class="headerlink" title="愉快地观看本地视频"></a>愉快地观看本地视频</h1><p><img src="https://img-blog.csdnimg.cn/20181125185319560.png" alt="如图片显示有问题请到csdn观看">如果你下载的视频在本地播放不了，请不要试图修改源代码中保存文件的格式由<code>.flv</code>改成<code>.mp4</code>,因为b站的视频本来就是flv格式的，需要用特殊的视频播放器播放，这里推荐一个无毒无害的KMPlayer,<a href="https://pan.baidu.com/s/1DBOaPGbdTXOvodbrZRhzmQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1DBOaPGbdTXOvodbrZRhzmQ</a>,提取码：fw0b </p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>工程所有源代码均已上传至github，<a href="https://github.com/inspurer/PythonSpider/tree/master/bilibili" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/bilibili</a><br>欢迎star,fork。<br>如图片显示有问题请到csdn观看<a href="https://blog.csdn.net/ygdxt/article/details/84501500" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/84501500</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python爬虫系列：&lt;br&gt;上一篇&lt;br&gt;&lt;a href=&quot;https://inspurer.github.io/2018/11/14/python%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93/#more&quot;&gt;python爬取图虫网图库&lt;/a&gt;&lt;br&gt;今天突然来了兴趣想要爬取下载b站视频，话不多说，说干就干。
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="b站" scheme="https://inspurer.github.io/tags/b%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>python函数参数的填坑之路</title>
    <link href="https://inspurer.github.io/2018/11/22/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>https://inspurer.github.io/2018/11/22/python函数参数的填坑之路/</id>
    <published>2018-11-22T12:08:55.000Z</published>
    <updated>2018-11-22T12:13:29.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在看<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="noopener">廖雪峰老师的python3教程之函数的参数</a><br>受益匪浅，但是在实践的过程中，发现了一些不解之谜<a id="more"></a></p><h1 id="两个错误"><a href="#两个错误" class="headerlink" title="两个错误"></a>两个错误</h1><pre><code>import _threadimport timedef func1(x):    while x:        print(x)        x = x -1_thread.start_new_thread(function=func1,args=(5,),kwargs=None)time.sleep(6)</code></pre><p>再看python3中start_new_thread()函数的声明</p><pre><code>def start_new_thread(function, args, kwargs=None):</code></pre><p>按照我们的理论，我们开启多线程的那句代码是完全没有问题的，可是事实上它报错：  </p><pre><code>TypeError: start_new_thread() takes no keyword arguments</code></pre><p>难道我们的理论有问题？带着这个疑问，我又遇到一个问题:</p><pre><code>import threadingdef func1(x):    while x:        print(x)        x = x -1threading.Thread(func1,(5,)).start()</code></pre><p>再看python3中Thread类构造()函数的声明</p><pre><code>def __init__(self, group=None, target=None, name=None,             args=(), kwargs=None, *, daemon=None):</code></pre><p>它居然又报错？</p><pre><code>AssertionError: group argument must be None for now</code></pre><h1 id="探讨过程"><a href="#探讨过程" class="headerlink" title="探讨过程"></a>探讨过程</h1><p>（以下过程针对第二个错误，第一个错误道理类似）<br>带着疑问，我看了Thread类的构造函数</p><pre><code>def __init__(self, group=None, target=None, name=None,     args=(), kwargs=None, *, daemon=None):      &quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are:       *group* should be None; reserved for future extension when a ThreadGroup        class is implemented.        *target* is the callable object to be invoked by the run()        method. Defaults to None, meaning nothing is called.        。。。略        assert group is None, &quot;group argument must be None for now&quot;        。。。略</code></pre><p>   我们看到，第三行说明，本函数只接受关键字实参调用，所以我们之前的代码改成</p><pre><code>import threadingdef func1(x):    while x:        print(x)        x = x -1threading.Thread(target=func1,args=(5,)).start()</code></pre><p>就能顺利开启子线程了，那么它是如何实现只能接受关键字参数的呢？<br>我们看到Thread类的构造函数定义中有一句这样的断言</p><pre><code>assert group is None, &quot;group argument must be None for now&quot;</code></pre><p>意思是，如果参数group为空,通过；如果非空，报错，并给出reason<code>group argument must be None for now</code>,如果我们按照之前的位置参数调用的话，由于group是第一个参数，一下在就被赋值，非空，抛出异常，这符合我们之前的实践。同时，我在网上搜集了许多资料，诸如<code>修饰器</code>之类的也能使函数只接受关键字参数 。</p><p>错误一探讨过程道理类似，在此不再赘述。</p><h1 id="验证及结论"><a href="#验证及结论" class="headerlink" title="验证及结论"></a>验证及结论</h1><p>编码</p><pre><code>class MyThread:    def __init__(self, group=None, target=None, name=None,    args=(), kwargs=None, *, daemon=None):        print(&apos;Thread sucess&apos;)    def start_new_thread(function, args, kwargs=None):    print(&apos;_thread sucess&apos;)MyThread()MyThread.start_new_thread(args=2,kwargs=3,function=1)</code></pre><p>输出如下：</p><pre><code>Thread sucess_thread sucess</code></pre><p>显而易见，我们之前所学的理论是正确的，只不过在具体的编码中，我们通过编码<code>修改</code><br>理论，使之看上去似乎和之前的理论相矛盾，千万不要被蒙蔽了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在看&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰老师的python3教程之函数的参数&lt;/a&gt;&lt;br&gt;受益匪浅，但是在实践的过程中，发现了一些不解之谜
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="函数参数" scheme="https://inspurer.github.io/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>罗素:我为什么而活</title>
    <link href="https://inspurer.github.io/2018/11/15/%E7%BD%97%E7%B4%A0-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB/"/>
    <id>https://inspurer.github.io/2018/11/15/罗素-我为什么而活/</id>
    <published>2018-11-15T05:44:21.000Z</published>
    <updated>2018-11-15T08:15:22.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文译文"><a href="#中文译文" class="headerlink" title="中文译文"></a>中文译文</h1><p>对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，<a id="more"></a>这三种纯洁而无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。</p><p>我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情可以解除孤寂一—那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想像的天堂景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。</p><p>我以同样的热情寻求知识，我渴望了解人的心灵。我渴望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。</p><p>爱情和知识，尽其可能地把我引上天堂，但是同情心总把我带回尘世。痛苦的呼唤经常在我心中回荡，饥饿的儿童，被压迫被折磨者，被儿女视为负担的无助的老人以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。</p><p>这就是我的一生，我觉得值得为它活着。如果有机会的话，我还乐意再活一次。</p><h1 id="英文原文"><a href="#英文原文" class="headerlink" title="英文原文"></a>英文原文</h1><font size="4" color="#ff0000">《What I Have Lived For》  by Bertrand Russell</font><p>Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a great ocean of anguish, reaching to the very verge of despair.</p><p>I have sought love, first, because it brings ecstasy - ecstasy so great that I would often have sacrificed all the rest of life for a few hours of this joy. I have sought it, next, because it relieves loneliness–that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what–at last–I have found.</p><p>With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved.</p><p>Love and knowledge, so far as they were possible, led upward toward the heavens. But always pity brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate this evil, but I cannot, and I too suffer.</p><p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;中文译文&quot;&gt;&lt;a href=&quot;#中文译文&quot; class=&quot;headerlink&quot; title=&quot;中文译文&quot;&gt;&lt;/a&gt;中文译文&lt;/h1&gt;&lt;p&gt;对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="鸡汤" scheme="https://inspurer.github.io/tags/%E9%B8%A1%E6%B1%A4/"/>
    
  </entry>
  
  <entry>
    <title>李开复:追随我心</title>
    <link href="https://inspurer.github.io/2018/11/14/%E6%9D%8E%E5%BC%80%E5%A4%8D-%E8%BF%BD%E9%9A%8F%E6%88%91%E5%BF%83/"/>
    <id>https://inspurer.github.io/2018/11/14/李开复-追随我心/</id>
    <published>2018-11-14T15:22:07.000Z</published>
    <updated>2018-11-14T15:40:09.811Z</updated>
    
    <content type="html"><![CDATA[<p>并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫<a id="more"></a>李开复,此君并非厌学,而是对政治科学越来越不感兴趣。蹉跎到大二下学期,他终于决定快刀斩乱麻——转系,改学自己感兴趣的计算机。</p><p>兴趣是什么?兴趣就意味着天赋。李开复在计算机系如鱼得水,左右逢源,两年后毕业,成绩居全系之首。这样的学生用不着按部就班。在教授的推荐下,李开复进入在计算机领域独领风骚的卡内基•梅隆大学,直接攻读博士。计算机学院的院长找他谈话,劈头就问:“读博士的目的是什么?”李开复大声答:“我从大学带走的将是一篇改变世界的、顶尖的博士论文。”院长予以纠正,说:“你从这儿带走的最有价值的东西,不是一篇论文,而是你分析、思考的能力,研究、发现真理的经验,以及科学家的胸怀。这样,当你有一天改变研究方向,依然可以在任何一个新的领域出类拔萃。”李开复选定语音识别为攻读方向,经过一年“热恋”,他发现专家系统其冷如冰,远不如统计学有情有义。李开复决心“移情别恋”。他担心导师发怒,谁知得到的回答竟是:“开复,你对专家系统和统计的观点,我是不赞同的,但我可以支持你用统计的方法去做,因为我相信科学没有绝对的对错,我们都是平等的。而且,我更相信一个富有激情的人可以找到更好的解决方案。”李开复从导师的大度悟到科学的真谛,他全力以赴,放手一搏。3年过去了,李开复的研究成果及博士论文,引发了那年语音世界最大的冲击波。26岁的李开复功成名就,成为卡内基•梅隆大学最年轻的副教授。天之骄子,有尊严,有地位,有课题,有经费,出任大公司顾问,飞赴各地讲学,包括去他的祖籍之邦、魂之所系的祖国大陆。</p><p>“让世界因你而不同!”这是李开复埋在心底多年的梦想。1990年,苹果公司的一个邀请电话让李开复开始审视自己:“开复,你是想一辈子写一堆像废纸一样的学术论文,还是想真正地改变世界?”面对苹果公司的召唤,李开复旋即做出回应,走出象牙塔,加盟“改变世界”的大军。在苹果公司,李开复感受到了从纸上谈兵转入实战的无穷乐趣。1995年,33岁的李开复出任苹果公司的副总裁。</p><p>但是他仍然不满足,依然要跳槽,因为硅谷的另一家公司SGI发出了更有诱惑力的邀请——“你想做什么,然后我们根据你的兴趣对公司进行改组。”不是他们缺什么人才,让你去填补,而是诚恳地询问你需要什么平台,以便为你量身搭建。这样的机遇,李开复岂能错过!双方一拍即合, 1996年7月,李开复跳槽去了SGI。李开复奉行“自己设计自己”的人生信条,怎奈SGI是一家硬件公司,开复的长处却在软件开发,这就等于在篮球场上跑马,任是赤兔、骅骝,也撒不开四蹄。日复一日,李开复萌生去意。对于下一个选择,他立下两条标准:一是做软件,二是去中国。</p><p>机会来了。其实机会无处不在,就看你有没有做好准备。彼时,比尔•盖茨创立的微软王国要把触角伸向中国,李开复成为它的不二人选。时间:1998年金秋;职务:微软中国研究院院长。李开复在中国市场的开拓,值得写部书来描述,那是一种完全不同的创新理念、绝对领先的科学技术在神州大地生根发芽。微软只是起用了一个人,就开拓了中国市场;李开复只是“追随我心”,就一跃成为微软王国的副总裁。在你我想来,这该是李开复的最后一站。在微软占据高位,与比尔•盖茨亲密共事,坐拥财富和风光,“花迎喜气皆知笑,鸟识欢心亦解歌”。人生至此,夫复何求?李开复不这么想,他后来回忆:“我如同一部庞大机器上的零件,在中规中矩、没有任何发挥空间的环境下运行着。这是一个随时随地都可以被替换的光鲜零件。那种价值的缺失感以及精神上的落寞占据了我的内心。”微软既然已无成长空间,那就走吧!到哪儿去?他相中了Google。但他清醒地意识到,管理更多的人马,不是自己的所爱,他渴望从无到有的创新,而不是经营一个巨无霸。于是,在2009年9月,李开复又一次选择潇洒地离去。向总部递交辞呈之际,Google高管艾伦•尤斯塔斯试图用更优厚的条件予以挽留。李开复真诚地说:“我的人生还有一个缺憾没有实现,现在得去弥补。我可能创办一家‘创新工场’,和中国青年一起创造新的技术奇迹。”</p><p>如今,李开复正在按照他本人的意愿,在神州大地进行“创新工场”试验。他会成功吗?我想这是毫无疑问的,也是次要又次要的,那么,最主要的一点是什么呢?诚如他自己所言:“人生在世时间非常短,如果你总是不敢做想做的事情,那么一生过去了,你留下来的只有悔恨,只有懊恼。”“我步入丛林,因为我希望生活得有意义,我希望活得深刻,并汲取生命中所有的精华,然后从中学习,以免让我在生命终结时,才发现自己从来没有活过。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="励志故事" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>python自动下载图虫网图库</title>
    <link href="https://inspurer.github.io/2018/11/14/python%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93/"/>
    <id>https://inspurer.github.io/2018/11/14/python自动下载图虫网图库/</id>
    <published>2018-11-14T12:58:11.000Z</published>
    <updated>2019-03-22T15:48:32.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="下载工程源码"><a href="#下载工程源码" class="headerlink" title="下载工程源码"></a>下载工程源码</h2><p><a href="https://github.com/inspurer/PythonSpider/tree/master/tuchong" target="_blank" rel="noopener">点击下载</a><br><a id="more"></a><br>或者git bash;<code>git clone git@github.com:inspurer/PythonSpider.git</code>    </p><h2 id="下载相关依赖"><a href="#下载相关依赖" class="headerlink" title="下载相关依赖"></a>下载相关依赖</h2><p>在命令行下依此输入   </p><pre><code>pip install requests   pip install pyquery   </code></pre><h2 id="打开图虫网"><a href="#打开图虫网" class="headerlink" title="打开图虫网"></a>打开图虫网</h2><p>选择你喜欢的图库链接,比如<code>https://tuchong.com/4293835/23849565/</code><br>复制并替换到tuchong_gallery.py代码里面的gallery_url,解释一下这个链接的作用,<br>前一个数字串是作者的id,后一个数字串是作者该图库的id<br>注意,在打开这个图库时,复制地址前最好不要左右浏览   </p><h2 id="运行tuchong-gallery-py"><a href="#运行tuchong-gallery-py" class="headerlink" title="运行tuchong_gallery.py"></a>运行tuchong_gallery.py</h2><p>你就可以看到在下载这个图库的图片了<br>图库保存在工程目录下,文件夹名为作者和图库的id<br>每一张图片保存在该文件夹下,格式为:<code>imageid.jpg</code>  </p><h1 id="计划更新"><a href="#计划更新" class="headerlink" title="计划更新"></a>计划更新</h1><h2 id="增加自动搜索"><a href="#增加自动搜索" class="headerlink" title="增加自动搜索"></a>增加自动搜索</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h1&gt;&lt;h2 id=&quot;下载工程源码&quot;&gt;&lt;a href=&quot;#下载工程源码&quot; class=&quot;headerlink&quot; title=&quot;下载工程源码&quot;&gt;&lt;/a&gt;下载工程源码&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/inspurer/PythonSpider/tree/master/tuchong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击下载&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://inspurer.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>小程序json.parse错误</title>
    <link href="https://inspurer.github.io/2018/11/14/%E5%B0%8F%E7%A8%8B%E5%BA%8Fjson-parse%E9%94%99%E8%AF%AF/"/>
    <id>https://inspurer.github.io/2018/11/14/小程序json-parse错误/</id>
    <published>2018-11-14T05:53:15.000Z</published>
    <updated>2018-11-14T06:51:30.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h1><h2 id="今天查看上线的微信小程序后台，发现了一个这样的错误"><a href="#今天查看上线的微信小程序后台，发现了一个这样的错误" class="headerlink" title="今天查看上线的微信小程序后台，发现了一个这样的错误:"></a>今天查看上线的微信小程序后台，发现了一个这样的错误:</h2><a id="more"></a><pre><code>Unexpected token in JSON at position 52;at pages/send/send onShow function;at api request success callback function   </code></pre><h2 id="于是我打开调试工具查看源代码并且调试"><a href="#于是我打开调试工具查看源代码并且调试" class="headerlink" title="于是我打开调试工具查看源代码并且调试:"></a>于是我打开调试工具查看源代码并且调试:</h2><pre><code>VM792:1 thirdScriptErrorUnexpected token in JSON at position 52;at pages/send/send onShow function;at api request success     callback functionSyntaxError: Unexpected token in JSON at position 52at JSON.parse (&lt;anonymous&gt;)at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35)at http://127.0.0.1:60162/appservice/utils/bmob.js:2293:37at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2219:48)at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17)at Bmob.Promise.resolve (http://127.0.0.1:60162/appservice/utils/bmob.js:2170:18)at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2228:37)at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17)   </code></pre><p>果不其然,小程序已然上线,这个错误一定不能忍     </p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><h2 id="通过错误信息定位到出错的代码"><a href="#通过错误信息定位到出错的代码" class="headerlink" title="通过错误信息定位到出错的代码"></a>通过错误信息定位到出错的代码</h2><p>通过上面的报错信息：<br><code>at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35)</code><br>定位到出错的代码是在130行:<br><code>var jsonB = JSON.parse(jsonA);</code>   </p><h2 id="上网浏览查询相关资料"><a href="#上网浏览查询相关资料" class="headerlink" title="上网浏览查询相关资料"></a>上网浏览查询相关资料</h2><p>网上的说法不一而足,实在不知道该听信哪家之言<br>不过都集中在<code>json文件不能有注释</code>、<code>json字符串url有误</code>、<code>json字符串有特殊字符</code>   </p><h2 id="定位原因"><a href="#定位原因" class="headerlink" title="定位原因"></a>定位原因</h2><p>排除了几种错误后还没有解决问题，有点心灰意冷,<br>尝试着输出json字符串中的每一个字符   </p><pre><code>51 &quot;。&quot;52 &quot;&quot;53 &quot;2&quot;</code></pre><p>等等,换行符确是是个特殊字符(ps,在js里面<code>\r</code>是回车符,<code>\n</code>是换行符,)<br>(在小程序中,我这个jsonA是包含用户的键盘输入信息的)   </p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><pre><code>jsonA = jsonA.replace(&apos;\n&apos;,&apos;&apos;)</code></pre><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>小程序的预览可以查看: <a href="https://inspurer.github.io/2018/11/07/%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/#more">点击查看</a><br>小程序的所有源代码: <a href="https://github.com/inspurer/CampusPunchcard" target="_blank" rel="noopener">github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;错误详情&quot;&gt;&lt;a href=&quot;#错误详情&quot; class=&quot;headerlink&quot; title=&quot;错误详情&quot;&gt;&lt;/a&gt;错误详情&lt;/h1&gt;&lt;h2 id=&quot;今天查看上线的微信小程序后台，发现了一个这样的错误&quot;&gt;&lt;a href=&quot;#今天查看上线的微信小程序后台，发现了一个这样的错误&quot; class=&quot;headerlink&quot; title=&quot;今天查看上线的微信小程序后台，发现了一个这样的错误:&quot;&gt;&lt;/a&gt;今天查看上线的微信小程序后台，发现了一个这样的错误:&lt;/h2&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://inspurer.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://inspurer.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="json" scheme="https://inspurer.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>【持续更新】hexo next主题优化手册</title>
    <link href="https://inspurer.github.io/2018/11/11/hexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <id>https://inspurer.github.io/2018/11/11/hexo-next主题优化/</id>
    <published>2018-11-11T13:24:19.000Z</published>
    <updated>2019-02-22T12:39:21.880Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/01/29/kQ7GIe.png" alt="Suzy"> <a id="more"></a>           </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="开此贴的原因"><a href="#开此贴的原因" class="headerlink" title="开此贴的原因"></a>开此贴的原因</h2><p>前几天博客崩了，重新搭建了这个博客站点。<br>特开此贴记录next主题优化过程中遇到的问题，希望对大家有所帮助。</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>前期相关的Hexo安装、本地/远程部署教程可百度在此不再赘述。<br>基于hexo-next v5.1.4,向上兼容,向下兼容性不确定，特此声明。<br>我的博客本地根目录是<code>D:\hexoblog</code><br>站点配置文件全路径是<code>‪D:\hexoblog\_config.yml</code><br>next主题文件全路径是<code>‪D:\hexoblog\themes\next\_config.yml</code>  </p><h2 id="hexo常见操作"><a href="#hexo常见操作" class="headerlink" title="hexo常见操作"></a>hexo常见操作</h2><p><code>hexo new &quot;postName&quot;</code> #新建文章<br><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo clean</code> #清除部署緩存<br><code>hexo n == hexo new</code> #新建文章<br><code>hexo g == hexo generate</code> #生成静态页面至public目录<br><code>hexo s == hexo server</code> #开启预览访问端口（默认端口4000，可在浏览器输入<code>localhost:4000</code>预览）<br><code>hexo d == hexo deploy</code> #将.deploy目录部署到GitHub<br><code>hexo g -d</code> #生成加部署<br><code>hexo g -s</code> #生成加预览    </p><hr><h1 id="next主题优化"><a href="#next主题优化" class="headerlink" title="next主题优化"></a>next主题优化</h1><h2 id="next风格选择"><a href="#next风格选择" class="headerlink" title="next风格选择"></a>next风格选择</h2><p>next有四种风格,在站点配置文件搜索字段<code>Scheme Settings</code>可以看到，  </p><pre><code># Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini</code></pre><p>我这里用的是四种：<code>Gemini</code>     </p><h2 id="next菜单设置"><a href="#next菜单设置" class="headerlink" title="next菜单设置"></a>next菜单设置</h2><p>比如可以看到我的主页有<code>首页</code>、<code>留言</code>、<code>分类</code>、<code>归档</code>、<code>标签</code>等菜单，<br>在站点配置文件下搜索<code>menu:</code>,可以看到   </p><pre><code>menu:  home: / || home  about: /about/ || user  message: /message/ || comment  tags: /tags/ || tags  categories: /categories/ || th  archives: /archives/ || archive  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat</code></pre><p><code>home</code>就是<code>首页</code>;<code>message</code>就是<code>留言</code>…一开始只有首页和归档,其余的需要我们手动创建，<br>在站点根目录下打开命令行,输入<code>hexo new page &quot;about&quot;</code><br>并在主题配置文件<code>menu:</code>字段处取消对about的注释<br>重新部署我们就可以看到主页有<code>关于</code>这个菜单了，其他的类似，<br>修改<code>D:\hexoblog\source\about\index.md</code>,就可以修改<code>关于</code>界面了<br><code>about: /about/ || user</code>中的<code>user</code>是指<code>关于</code>菜单附件的图标用的是<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">图标库</a>里面名为<code>user</code>的图标   </p><h2 id="添加萌妹子动图"><a href="#添加萌妹子动图" class="headerlink" title="添加萌妹子动图"></a>添加萌妹子动图</h2><h3 id="在根目录下打开命令行"><a href="#在根目录下打开命令行" class="headerlink" title="在根目录下打开命令行"></a>在根目录下打开命令行</h3><p>输入<code>npm install --save hexo-helper-live2d</code>   </p><h3 id="修改站点配置文件-注意不是主题配置文件"><a href="#修改站点配置文件-注意不是主题配置文件" class="headerlink" title="修改站点配置文件(注意不是主题配置文件)"></a>修改站点配置文件(注意不是主题配置文件)</h3><p>在末尾加入:    </p><pre><code>live2d:      enable: true      scriptFrom: local      model:        scale: 1        hHeadPos: 0.5        vHeadPos: 0.618      display:        superSample: 2        width: 150        height: 300        position: right        hOffset: 0        vOffset: -20     mobile:        show: false      react:        opacityDefault: 0.5        opacityOnHover: 0.</code></pre><h2 id="实现文章首页”分类于”、”阅读次数”等效果"><a href="#实现文章首页”分类于”、”阅读次数”等效果" class="headerlink" title="实现文章首页”分类于”、”阅读次数”等效果"></a>实现文章首页”分类于”、”阅读次数”等效果</h2><p>效果图如下:<br><img src="https://i.imgur.com/sIHtbOe.png" alt="">     </p><h3 id="在根目录下打开命令行-1"><a href="#在根目录下打开命令行-1" class="headerlink" title="在根目录下打开命令行"></a>在根目录下打开命令行</h3><p>依次输入以下命令:    </p><pre><code>npm install hexo-wordcount --savenpm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save   </code></pre><h3 id="打开主题配置文件"><a href="#打开主题配置文件" class="headerlink" title="打开主题配置文件"></a>打开主题配置文件</h3><p>打开相关开关:   </p><pre><code>post_wordcount:    item_text: true    wordcount: true    min2read: true    totalcount: true</code></pre><h3 id="打开…-themes-next-layout-macro-post-swig文件"><a href="#打开…-themes-next-layout-macro-post-swig文件" class="headerlink" title="打开…/themes/next/layout/_macro/post.swig文件"></a>打开…/themes/next/layout/_macro/post.swig文件</h3><p>把里面的代码用下面的代码替换:<br><a href="https://pan.baidu.com/s/1v7fZrMTzFILCWS-hoo0igA" target="_blank" rel="noopener">点击下载</a>    </p><h3 id="打开…-themes-next-languages-zh-Hans-yml文件"><a href="#打开…-themes-next-languages-zh-Hans-yml文件" class="headerlink" title="打开…/themes/next/languages/zh-Hans.yml文件"></a>打开…/themes/next/languages/zh-Hans.yml文件</h3><p>搜索<code>post</code>字段,添加一行<code>comments: 评论数</code>,注意其余的不要改   </p><h3 id="设置某篇文章置顶"><a href="#设置某篇文章置顶" class="headerlink" title="设置某篇文章置顶"></a>设置某篇文章置顶</h3><p>前面的流程走完后,只需要在写文章的时候在文章前面加入top: true<br>或者top: 100(100只是个例子，数字越大越靠前),就能实现置顶效果了    </p><hr><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="本地预览和同时发布到远程的浏览结果不一致"><a href="#本地预览和同时发布到远程的浏览结果不一致" class="headerlink" title="本地预览和同时发布到远程的浏览结果不一致"></a>本地预览和同时发布到远程的浏览结果不一致</h2><p>这是由缓存造成的,需要先<code>hexo clean</code>,再<code>hexo g -d</code>部署到远程    </p><hr><h1 id="markdown高级语法"><a href="#markdown高级语法" class="headerlink" title="markdown高级语法"></a>markdown高级语法</h1><h2 id="插入连续多行的代码块"><a href="#插入连续多行的代码块" class="headerlink" title="插入连续多行的代码块"></a>插入连续多行的代码块</h2><p>按一个tab键,然后贴代码，保证每一行代码前都要额外的tab键,同时最前面空一行。<br>比如,我前面插入的连续行代码的实现效果:<br><img src="https://i.imgur.com/Z0BCMhF.png" alt="">      </p><h2 id="设置文字大小和颜色和居中效果"><a href="#设置文字大小和颜色和居中效果" class="headerlink" title="设置文字大小和颜色和居中效果"></a>设置文字大小和颜色和居中效果</h2><p>hello,world!    </p><p><font color="#FF0000"> hello,world! </font>    </p><p><font size="5"> hello,world! </font>     </p><p><font size="5" color="#FF0000">hello,world! </font>    </p><p><center>hello,world!</center><br>上面的效果需要在markdwon中的代码是这样的:   </p><pre><code>hello,world!    &lt;font color=&quot;#FF0000&quot;&gt; hello,world! &lt;/font&gt;    &lt;font size=5&gt; hello,world! &lt;/font&gt;     &lt;font size=5 color=&quot;#FF0000&quot;&gt;hello,world! &lt;/font&gt;    &lt;center&gt;hello,world!&lt;/center&gt;    </code></pre><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>效果图:   </p><table><thead><tr><th style="text-align:left">左对齐标题</th><th style="text-align:right">右对齐标题</th><th style="text-align:center">居中对齐标题</th></tr></thead><tbody><tr><td style="text-align:left">短文本</td><td style="text-align:right">中等文本</td><td style="text-align:center">稍微长一点的文本</td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:right">短文本</td><td style="text-align:center">中等文本</td></tr></tbody></table><p>markdown代码如下：    </p><pre><code>| 左对齐标题 | 右对齐标题 | 居中对齐标题 || :------| ------: | :------: || 短文本 | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 |</code></pre><hr><h1 id="感谢赞助"><a href="#感谢赞助" class="headerlink" title="感谢赞助"></a>感谢赞助</h1><p>所有赞赏过本站的人: <a href="https://inspurer.github.io/thank/">点击查看</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/29/kQ7GIe.png&quot; alt=&quot;Suzy&quot;&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://inspurer.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://inspurer.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://inspurer.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>Windows下操作POP3</title>
    <link href="https://inspurer.github.io/2018/11/10/Windows%E4%B8%8B%E6%93%8D%E4%BD%9CPOP3/"/>
    <id>https://inspurer.github.io/2018/11/10/Windows下操作POP3/</id>
    <published>2018-11-10T04:11:12.000Z</published>
    <updated>2019-03-22T15:48:23.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows10下开启telnet服务"><a href="#Windows10下开启telnet服务" class="headerlink" title="Windows10下开启telnet服务"></a>Windows10下开启telnet服务</h2><p>在自学<em>《计算机网络-自顶向下方法》</em>这本书中，<code>telnet</code>这个服务命令出现了好多次，  <a id="more"></a><br>开始在<em>Ubuntu 12.0</em>终端下输入<code>telnet</code>是有正确响应的，但是在<em>windows 10</em>命令行下<br>输入提示找不到该命令，直到今天我才发现该服务在<em>window 1o</em>下是默认关闭的，需要手动打开<br>开启步骤如下    </p><h3 id="1-用小娜以关键词功能找到开启和关闭Windows功能"><a href="#1-用小娜以关键词功能找到开启和关闭Windows功能" class="headerlink" title="1.用小娜以关键词功能找到开启和关闭Windows功能"></a>1.用小娜以关键词<em>功能</em>找到<em>开启和关闭Windows功能</em></h3><p><img src="https://i.imgur.com/uDffqOV.png" alt=""><br>其实不一定要这样操作，找到<em>开启和关闭Windows功能</em>即可      </p><h3 id="2-勾选Telnet客户端并确定"><a href="#2-勾选Telnet客户端并确定" class="headerlink" title="2.勾选Telnet客户端并确定"></a>2.勾选<em>Telnet客户端</em>并确定</h3><p><img src="https://i.imgur.com/ZpsU915.png" alt=""><br>然后就可以愉快地在windows10玩耍telnet了     </p><h2 id="Windows下操作POP3"><a href="#Windows下操作POP3" class="headerlink" title="Windows下操作POP3"></a>Windows下操作POP3</h2><p>pop3是一个邮件访问协议   </p><h3 id="1-在cmd下输入telnet-pop3-163-com-110登录到qq的POP3服务器的110端口"><a href="#1-在cmd下输入telnet-pop3-163-com-110登录到qq的POP3服务器的110端口" class="headerlink" title="1.在cmd下输入telnet pop3.163.com 110登录到qq的POP3服务器的110端口"></a>1.在cmd下输入<code>telnet pop3.163.com 110</code>登录到qq的POP3服务器的110端口</h3><h3 id="2-依次输入user-csu-xiaotao和pass-xxxxxxxxx登录到自己的邮箱"><a href="#2-依次输入user-csu-xiaotao和pass-xxxxxxxxx登录到自己的邮箱" class="headerlink" title="2.依次输入user csu_xiaotao和pass xxxxxxxxx登录到自己的邮箱"></a>2.依次输入<code>user csu_xiaotao</code>和<code>pass xxxxxxxxx</code>登录到自己的邮箱</h3><p>需要注意的是,<code>xxxxxxxxx</code>是邮箱的授权码，不是登录密码    </p><h3 id="3-然后是一些常见的pop3命令-大小写敏感）"><a href="#3-然后是一些常见的pop3命令-大小写敏感）" class="headerlink" title="3.然后是一些常见的pop3命令(大小写敏感）"></a>3.然后是一些常见的pop3命令(大小写敏感）</h3><h4 id="1-list列出所有的收到的邮件，特别的-list-n’列出第n封邮件"><a href="#1-list列出所有的收到的邮件，特别的-list-n’列出第n封邮件" class="headerlink" title="1.list列出所有的收到的邮件，特别的`list n’列出第n封邮件"></a>1.<code>list</code>列出所有的收到的邮件，特别的`list n’列出第n封邮件</h4><p>其响应格式如下:<br><code>n m</code><br>其中n为第n封邮件，m为第n封邮件的字节大小    </p><h4 id="2-retr-n下载第n封邮件"><a href="#2-retr-n下载第n封邮件" class="headerlink" title="2.retr n下载第n封邮件"></a>2.<code>retr n</code>下载第n封邮件</h4><p>其响应格式如下：<br><img src="https://i.imgur.com/lQJLbpd.png" alt=""><br>采用了特殊的编码格式，我们可能看不懂     </p><h4 id="3-dele-n删除第n封邮件"><a href="#3-dele-n删除第n封邮件" class="headerlink" title="3.dele n删除第n封邮件"></a>3.<code>dele n</code>删除第n封邮件</h4><h4 id="4-uidl-n返回第n封邮件的唯一标识"><a href="#4-uidl-n返回第n封邮件的唯一标识" class="headerlink" title="4.uidl n返回第n封邮件的唯一标识"></a>4.<code>uidl n</code>返回第n封邮件的唯一标识</h4><h4 id="5-quit退出"><a href="#5-quit退出" class="headerlink" title="5.quit退出"></a>5.<code>quit</code>退出</h4><p>注意<code>+OK</code>代表操作成功；<code>-ERR</code>代表操作失败     </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Windows10下开启telnet服务&quot;&gt;&lt;a href=&quot;#Windows10下开启telnet服务&quot; class=&quot;headerlink&quot; title=&quot;Windows10下开启telnet服务&quot;&gt;&lt;/a&gt;Windows10下开启telnet服务&lt;/h2&gt;&lt;p&gt;在自学&lt;em&gt;《计算机网络-自顶向下方法》&lt;/em&gt;这本书中，&lt;code&gt;telnet&lt;/code&gt;这个服务命令出现了好多次，
    
    </summary>
    
      <category term="计算机网络" scheme="https://inspurer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="pop3" scheme="https://inspurer.github.io/tags/pop3/"/>
    
      <category term="telnet" scheme="https://inspurer.github.io/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>打卡微信小程序</title>
    <link href="https://inspurer.github.io/2018/11/07/%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://inspurer.github.io/2018/11/07/打卡微信小程序/</id>
    <published>2018-11-07T11:41:19.000Z</published>
    <updated>2019-03-22T15:48:44.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打卡微信小程序。"><a href="#打卡微信小程序。" class="headerlink" title="打卡微信小程序。"></a>打卡微信小程序。</h1><h1 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h1><h2 id="1、类似论坛，可发帖、评论、回复。"><a href="#1、类似论坛，可发帖、评论、回复。" class="headerlink" title="1、类似论坛，可发帖、评论、回复。"></a>1、类似论坛，可发帖、评论、回复。</h2><a id="more"></a>    <h2 id="2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。"><a href="#2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。" class="headerlink" title="2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。"></a>2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。</h2><h2 id="3、跑步也可换算积分，换算的规则男女有别。"><a href="#3、跑步也可换算积分，换算的规则男女有别。" class="headerlink" title="3、跑步也可换算积分，换算的规则男女有别。"></a>3、跑步也可换算积分，换算的规则男女有别。</h2><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="https://i.imgur.com/HROakCa.jpg" alt=""><br><img src="https://i.imgur.com/JtbINuy.jpg" alt=""><br><img src="https://i.imgur.com/huWnNXu.jpg" alt=""><br><img src="https://i.imgur.com/hvKAPCi.jpg" alt=""><br><img src="https://i.imgur.com/xcUyMnX.jpg" alt=""><br><img src="https://i.imgur.com/A2ppD0v.jpg" alt=""><br><img src="https://i.imgur.com/TYXFybN.jpg" alt=""><br><img src="https://i.imgur.com/NNazajL.jpg" alt=""><br><img src="https://i.imgur.com/qlOLDji.jpg" alt="">    </p><h1 id="核心js代码"><a href="#核心js代码" class="headerlink" title="核心js代码"></a>核心js代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    var Bmob = require(&quot;../../utils/bmob.js&quot;);    var common = require(&quot;../../utils/common.js&quot;);    Bmob.initialize(&quot;*************************&quot;, &quot;**************************&quot;);    Page({      /**       * 页面的初始数据       */      data: {        canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;),        hiddenmodalput: true,        cname: &apos;&apos;,        sexx: &apos;&apos;,        iname: &apos;&apos;,      },      cancel: function(e){        wx.showToast({          title: &apos;务必输入&apos;,          icon: &apos;loading&apos;        })      },      cn:function(e){        console.log(e.detail.value)        this.setData({          cname: e.detail.value        })      },      se: function (e) {        console.log(e.detail.value)        this.setData({          sexx: e.detail.value        })      },      ina: function(e){        this.setData({          iname:e.detail.value        })      },      confirm: function (e) {        var that = this;        if (!(that.data.sexx == &apos;男&apos; || that.data.sexx == &apos;女&apos;)){          wx.showToast({            title: &apos;性别输入有误&apos;,          })          return;        }        if(!that.data.cname){          wx.showToast({            title: &apos;姓名班级有误&apos;,          })          return;        }        if(that.data.iname.length&gt;0)        {          var User = Bmob.Object.extend(&quot;_User&quot;);          var query = new Bmob.Query(User);          query.equalTo(&apos;nickname&apos;, that.data.iname)          query.find({            success: function (results) {              if (results.length == 0) {                wx.showToast({                  title: &apos;无此邀请人&apos;,                  icon: &apos;loading&apos;                })                return;              }              var user = Bmob.User.logIn(results[0].get(&apos;username&apos;), results[0].get(&apos;userData&apos;).openid, {                success: function (users) {                  var score = users.get(&apos;score&apos;);                  score = score + 2;                  users.set(&apos;score&apos;, score);                  users.save(null, {                    success: function (user) {                      wx.showToast({                        title: &apos;被邀请成功&apos;,                        icon: &apos;success&apos;                      })                    },                    error: function (error) {                      console.log(error)                    }                  });                }              });            }          })        }        this.setData({          hiddenmodalput: true,        })        wx.getStorage({          key: &apos;my_username&apos;,          success: function (ress) {            if (ress.data) {              var my_username = ress.data;              wx.getStorage({                key: &apos;user_openid&apos;,                success: function (openid) {                  var openid = openid.data;                  var user = Bmob.User.logIn(my_username, openid, {                    success: function (users) {                      users.set(&apos;nickname&apos;, that.data.cname);                      users.set(&apos;sex&apos;,that.data.sexx)                      users.save(null, {                        success: function (user) {                          wx.setStorageSync(&apos;my_nick&apos;, that.data.cname);                          wx.setStorageSync(&quot;sex&quot;, that.data.sexx);                        },                        error: function (error) {                          console.log(error)                        }                      });                    }                  });                }, function(error) {                  console.log(error);                }              })            }          }        })        wx.switchTab({          url: &apos;../punch/punch&apos;,        });      },      /**       * 生命周期函数--监听页面加载       */      onLoad: function (options) {      },      bindGetUserInfo: function (e) {        var that = this;        // 查看是否授权        wx.getSetting({          success: function (res) {            if (res.authSetting[&apos;scope.userInfo&apos;]) {              console.log(&quot;已授权&quot;)              // 已经授权，可以直接调用 getUserInfo 获取头像昵称                  //调用API从本地缓存中获取数据                  try {                    var value = wx.getStorageSync(&apos;user_openid&apos;)                    if (value) {                      console.log(&quot;value不为空&quot;)                      wx.switchTab({                        url: &apos;../punch/punch&apos;,                      })                    } else {                      console.log(&quot;value为空&quot;)                      wx.login({                        success: function (res) {                          console.log(&apos;res&apos;, res)                          if (res.code) {                            Bmob.User.requestOpenId(res.code, {                              success: function (userData) {                                console.log(&apos;uD&apos;,userData)                                    var userInfo = e.detail.userInfo;                                    var nickName = userInfo.nickName;                                    var avatarUrl = userInfo.avatarUrl;                                    Bmob.User.logIn(nickName, userData.openid, {                                      success: function (user) {                                        try {                                          console.log(&apos;sex&apos;+user.get(&apos;sex&apos;));                                          console.log(&apos;score&apos; + user.get(&apos;score&apos;));                                          wx.setStorageSync(&quot;newsnum&quot;, user.get(&apos;newsnum&apos;))                                          wx.setStorageSync(&quot;sex&quot;, user.get(&apos;sex&apos;));                                          wx.setStorageSync(&quot;score&quot;, user.get(&apos;score&apos;));                                          wx.setStorageSync(&apos;user_openid&apos;, user.get(&quot;userData&quot;).openid)                                          wx.setStorageSync(&apos;user_id&apos;, user.id);                                          wx.setStorageSync(&apos;my_nick&apos;, user.get(&quot;nickname&quot;))                                          wx.setStorageSync(&apos;my_username&apos;, user.get(&quot;username&quot;))                                          wx.setStorageSync(&apos;my_avatar&apos;, user.get(&quot;userPic&quot;))                                        } catch (e) {                                        }                                        console.log(&quot;登录成功y&quot;);                                      },                                      error: function (user, error) {                                        console.log(&apos;test&apos;,error)                                        if (error.code == &quot;101&quot;) {                                          that.setData({                                            hiddenmodalput: false,                                          })                                          var user = new Bmob.User();//开始注册用户                                          user.set(&quot;username&quot;, nickName);                                          user.set(&quot;password&quot;, userData.openid);//因为密码必须提供，但是微信直接登录小程序是没有密码的，所以用openId作为唯一密码                                                             user.set(&quot;sex&quot;,&quot;男&quot;);                                          user.set(&quot;score&quot;,0);                                          user.set(&apos;newsnum&apos;,0);                                          user.set(&quot;nickname&quot;, nickName);                                          user.set(&quot;userPic&quot;, avatarUrl);                                          user.set(&quot;userData&quot;, userData);                                          user.signUp(null, {                                            success: function (results) {                                              try {//将返回的3rd_session储存到缓存                                                wx.setStorageSync(&apos;user_openid&apos;, results.get(&quot;userData&quot;).openid)                                                wx.setStorageSync(&apos;user_id&apos;, results.id);                                                wx.setStorageSync(&apos;my_username&apos;, results.get(&quot;username&quot;));                                                wx.setStorageSync(&quot;newsnum&quot;, results.get(&apos;newsnum&apos;));                                                wx.setStorageSync(&quot;score&quot;, 0);                                                wx.setStorageSync(&quot;sex&quot;, &quot;男&quot;);                                                wx.setStorageSync(&apos;my_nick&apos;, results.get(&quot;nickname&quot;));                                                wx.setStorageSync(&apos;my_avatar&apos;, results.get(&quot;userPic&quot;)                                                )                                                console.log(&quot;注册成功!&quot;);                                              } catch (e) {                                              }                                            },                                            error: function (userData, error) {                                              console.log(error)                                            }                                          });                                        }                                      }                                    });                              },                            });                          }                           else {                            console.log(&apos;获取用户登录态失败！&apos; + res.errMsg)                          }                        },                      });                    }                  } catch (e) {                    console.log(&quot;登陆失败&quot;)                  }                  wx.checkSession({                    success: function () {                    },                    fail: function () {                      //登录态过期                      wx.login()                    }                  })            }          }        })      },      /**       * 生命周期函数--监听页面初次渲染完成       */      onReady: function () {      },      /**       * 生命周期函数--监听页面显示       */      onShow: function () {      },      /**       * 生命周期函数--监听页面隐藏       */      onHide: function () {      },      /**       * 生命周期函数--监听页面卸载       */      onUnload: function () {      },      /**       * 页面相关事件处理函数--监听用户下拉动作       */      onPullDownRefresh: function () {        wx.stopPullDownRefresh()      },      /**       * 页面上拉触底事件的处理函数       */      onReachBottom: function () {      },      /**       * 用户点击右上角分享       */      onShareAppMessage: function () {      }    })```</code></pre><p><code>`</code>  </p><h1 id="github地址-欢迎star、fork"><a href="#github地址-欢迎star、fork" class="headerlink" title="github地址,欢迎star、fork!!!"></a><a href="https://github.com/inspurer/CampusPunchcard" target="_blank" rel="noopener">github地址</a>,欢迎star、fork!!!</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;打卡微信小程序。&quot;&gt;&lt;a href=&quot;#打卡微信小程序。&quot; class=&quot;headerlink&quot; title=&quot;打卡微信小程序。&quot;&gt;&lt;/a&gt;打卡微信小程序。&lt;/h1&gt;&lt;h1 id=&quot;实现功能&quot;&gt;&lt;a href=&quot;#实现功能&quot; class=&quot;headerlink&quot; title=&quot;实现功能&quot;&gt;&lt;/a&gt;实现功能&lt;/h1&gt;&lt;h2 id=&quot;1、类似论坛，可发帖、评论、回复。&quot;&gt;&lt;a href=&quot;#1、类似论坛，可发帖、评论、回复。&quot; class=&quot;headerlink&quot; title=&quot;1、类似论坛，可发帖、评论、回复。&quot;&gt;&lt;/a&gt;1、类似论坛，可发帖、评论、回复。&lt;/h2&gt;
    
    </summary>
    
      <category term="小程序" scheme="https://inspurer.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="打卡" scheme="https://inspurer.github.io/tags/%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于opencv人脸识别的员工考勤系统</title>
    <link href="https://inspurer.github.io/2018/09/25/%E5%9F%BA%E4%BA%8Eopencv%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84%E5%91%98%E5%B7%A5%E8%80%83%E5%8B%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://inspurer.github.io/2018/09/25/基于opencv人脸识别的员工考勤系统/</id>
    <published>2018-09-25T13:37:57.000Z</published>
    <updated>2019-03-22T15:48:12.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WorkAttendanceSystem"><a href="#WorkAttendanceSystem" class="headerlink" title="WorkAttendanceSystem"></a>WorkAttendanceSystem</h1><p>一个基于opencv人脸识别的员工考勤系统，<a id="more"></a>作者某双一流A类大学里的二流学生，写于2018/09/，python课设期间。    </p><hr><h1 id="工程简介"><a href="#工程简介" class="headerlink" title="工程简介"></a>工程简介</h1><h1 id="项目结构是V1-0版本的，V2-0的介绍请看文末更新版块"><a href="#项目结构是V1-0版本的，V2-0的介绍请看文末更新版块" class="headerlink" title="项目结构是V1.0版本的，V2.0的介绍请看文末更新版块"></a><strong>项目结构是V1.0版本的，V2.0的介绍请看文末更新版块</strong></h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>mainui.py是主界面，调用face_img_register.py和face_recognize_punchcard.py<br>其中face_img_register.py是录入人脸信息，face_recognize_punchcard.py是刷脸考勤<br>face_feature_storage.py属于鸡肋文件，没什么用，舍不得删，毕竟有点参考价值。<br>face_recognize_punchcard_lib.py和face_recognize_punchcard.py本质上差不多，<br>但是前者是给face_img_register.py专有的依赖。防止录入两个同样的人脸建不同数据库的风险。   </p><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><h3 id="1-主界面"><a href="#1-主界面" class="headerlink" title="1. 主界面"></a>1. 主界面</h3><p><img src="https://i.imgur.com/fNw0Mgj.png" alt="">   </p><h3 id="2-人脸录入"><a href="#2-人脸录入" class="headerlink" title="2. 人脸录入"></a>2. 人脸录入</h3><p><img src="https://i.imgur.com/Gg3hmBs.png" alt="">    </p><h3 id="3-刷脸考勤"><a href="#3-刷脸考勤" class="headerlink" title="3. 刷脸考勤"></a>3. 刷脸考勤</h3><p><img src="https://i.imgur.com/ymz7nYV.png" alt=""></p><p>其余的就不多做展示了，有什么问题欢迎<a href="mailto:2391527690@qq.com" target="_blank" rel="noopener">2391527690@qq.com</a>联系      </p><hr><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="V1-0版本"><a href="#V1-0版本" class="headerlink" title="V1.0版本"></a>V1.0版本</h2><h3 id="2018-9-23更新"><a href="#2018-9-23更新" class="headerlink" title="2018/9/23更新"></a>2018/9/23更新</h3><p>mainui.py–&gt;myapp.py<br>face_recognize_punchcard_lib.py等鸡肋文件放到useless文件夹里<br>运行效率显著提高   </p><h3 id="2018-9-25更新"><a href="#2018-9-25更新" class="headerlink" title="2018/9/25更新"></a>2018/9/25更新</h3><p>解决同步性问题，新录入的人脸能立即被识别<br>代码的运行速度少许下降    </p><h2 id="V2-0版本"><a href="#V2-0版本" class="headerlink" title="V2.0版本"></a>V2.0版本</h2><h3 id="1-全新设计的UI-更人性化的操作"><a href="#1-全新设计的UI-更人性化的操作" class="headerlink" title="1. 全新设计的UI,更人性化的操作"></a>1. 全新设计的UI,更人性化的操作</h3><p><img src="https://i.imgur.com/2dDK3Yo.png" alt=""><img src="https://i.imgur.com/UgpBEwb.png" alt=""><img src="https://i.imgur.com/ABcKPML.png" alt="">     </p><h3 id="2-数据更加安全，用户不可见"><a href="#2-数据更加安全，用户不可见" class="headerlink" title="2. 数据更加安全，用户不可见"></a>2. 数据更加安全，用户不可见</h3><p>人脸数据和签到日志全部保存在inspurer.db数据库文件里，更加安全；而且对人脸数据进行了压缩，更加小巧。   </p><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h3><ol><li>打开摄像头时请左右晃动一下人脸，确保人脸识别开始。   </li><li>人脸识别时做了拒绝处理，多张人脸时，只取距离屏幕最近的人脸。      </li><li><code>新建录入</code>时会自动录入十张人脸照片，也可手动点击<code>完成录入</code>立即完成，之后就会计算人脸数据并存储到数据库中，<br>左边的信息栏会有相应的信息打印。   </li><li><code>开始签到</code>后，如不点击<code>结束签到</code>,就会一直对屏幕前的人脸进行签到，签到状态分三种,未识别的人脸，签到成功，<br>签到成功但是迟到了(9.00后签到),重复签到(此时签到日志不会写入到数据库。         </li><li>为确保程序稳定性，每一个菜单里的按钮尽量成对操作。    </li></ol><hr><p>Thanks for your attention;<br>can you fork it if helping you? Thanks again！<br>CopyRight <a href="mailto:2391527690@qq.com" target="_blank" rel="noopener">2391527690@qq.com</a>;<br>send me for allowance if you want to transmit it  </p><h1 id="源代码地址"><a href="#源代码地址" class="headerlink" title="源代码地址"></a>源代码地址</h1><p><a href="https://github.com/inspurer/WorkAttendanceSystem" target="_blank" rel="noopener">github</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WorkAttendanceSystem&quot;&gt;&lt;a href=&quot;#WorkAttendanceSystem&quot; class=&quot;headerlink&quot; title=&quot;WorkAttendanceSystem&quot;&gt;&lt;/a&gt;WorkAttendanceSystem&lt;/h1&gt;&lt;p&gt;一个基于opencv人脸识别的员工考勤系统，
    
    </summary>
    
      <category term="python" scheme="https://inspurer.github.io/categories/python/"/>
    
    
      <category term="人脸识别" scheme="https://inspurer.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之单链表</title>
    <link href="https://inspurer.github.io/2018/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://inspurer.github.io/2018/09/12/数据结构之单链表/</id>
    <published>2018-09-12T06:34:18.000Z</published>
    <updated>2018-11-10T06:59:51.117Z</updated>
    
    <content type="html"><![CDATA[<p>从今天起开始数据结构系列的分享，今天分享的是单链表。<a id="more"></a><br>单链表大概是大概是每个数据结构初学者的必经之路，下面结合一个小小的工程<br>来深入学习单链表的使用–简易客户管理系统。<br>ps：如果还不清楚单链表是什么的小伙伴自行百度，在此不在赘述   </p><hr><p>#项目结构<br>如图所示<br><img src="https://i.imgur.com/ndpa8Mo.png" alt=""><br>大致了解了项目架构后，下面开始从零编写代码<br><strong>注：增、删、改这三个部分同时包含了将变动后的信息写入到文件中的操作</strong>    </p><hr><p>#代码编写</p><p>##项目基础代码<br>俗话说得好，“万丈高楼平地起”，先来编写项目的预定义代码部分，主要是头文件<br>包含、结构体定义、全局变量定义等    </p><p>###头文件包含<br><code>#include&lt;stdio.h&gt;    //C程序基础库</code><br><code>#include&lt;stdlib.h&gt;    //包含函数exit()</code><br><code>#include&lt;string.h&gt; //包含函数strcmp()</code>  </p><p>###结构体定义   </p><p><pre name="code" class="c++"><br>typedef struct item{<br>    char name[20];    //保存客户姓名<br>    char gender[20];  //保存客户性别<br>    int  age;         //保存客户年龄<br>    char tel[20];     //保存客户号码<br>} guest;<br></pre><br>结构体定义不要多说了哈，这里<code>typedef...guest</code>是给<strong>结构体item起别名</strong>的意思，也就是<br><code>struct item</code>在这个源文件里面等价于<code>guest</code>   </p><p><pre name="code" class="c++"><br>typedef struct node {<br>    guest data;         //数据域<br>    struct node <em> next; //指针域<br>}</em> link;<br></pre><br>这里是给<strong>指向结构体node的指针起别名</strong></p><p>###全局变量定义<br><code>link T;//头指针</code><br>这个头指针T是整个系统的索引，六个模块共有一个，虽然有尽量少定义全局变量的原则，但这里<br>的全局变量T可以避免各个函数间复杂的参数传递问题，牺牲了空间，换取了运行时间的减少；<br>同时要注意我在后面对T的初始化代码   </p><p><pre name="code" class="c++"><br>//初始化头指针<br>T=(link)malloc(sizeof(struct node));<br>T-&gt;next = NULL;<br></pre><br>这里并没有给T安排数据域，T不是第一个存储客户信息的节点指针，T-&gt;next才是，初始化头指针<br>时还没有存储客户信息的结点加入，所以<code>T-&gt;next=NULL;</code>,这是一个编程者应该养成的好习惯；为<br>什么不给T安排数据域呢，这里主要考虑到后面的删除模块的编写，我们知道，删除一个结点，要先<br>找到这个结点的前驱指针p和后驱指针q，然后<code>p-&gt;next = q-&gt;next；</code>,如果给T安排数据域的话，<br>T的前驱是什么呢？就算不用上面我说的那套删除逻辑，用<code>if...else...</code>语句和另外一套逻辑<br>完成对T的删除，代码明显复杂些。 </p><p>##项目核心代码   </p><p>###一、加载文件<br>代码如下   </p><p><pre name="code" class="c++"><br>void init() {<br>    link p,s;<br>    FILE *fp;<br>    int i  = 0;<br>    s = p=(link)malloc(sizeof(struct node));<br>    p-&gt;next = NULL;<br>    if((fp=fopen(“1.txt”,”r”))==NULL) {<br>        printf(“load error!”);<br>        exit(1);<br>    }<br>    while(!feof(fp)) {<br>        fscanf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,&amp;p-&gt;data.age,p-&gt;data.tel);<br>        i++;<br>        if(i!=1) {<br>            s-&gt;next = p;<br>            s=p;<br>        }<br>        else{<br>            T-&gt;next = p;<br>        }<br>        p=(link)malloc(sizeof(struct node));<br>        p-&gt;next = NULL;<br>    }<br>    printf(“总人数i=====%d\n”,i);<br>    if(fclose(fp)) {<br>        printf(“Can’t close the file!\n”);<br>        exit(1);<br>    }<br>}<br></pre><br>介绍下代码逻辑，新开辟内存空间，并使s、p指向它，打开文件，如果文件指针没有到文件尾，将<br>从文件读取到的一个客户信息赋给p的数据域，如果是读取第一个客户信息，将p指向的结点连在头<br>指针T后面，否则，将p连在s后面，因为这个时候s是p的前驱指针，连接成功后将p赋值给s，p又<br>指向一个新开辟的结点…<br>图示：<br><img src="https://i.imgur.com/hSpoXhg.png" alt="">     </p><p>###二、增加客户<br>代码如下：</p><p><pre name="code" class="c++"><br>//添加<br>void create() {<br>    link p,s;<br>    FILE *fp;<br>    int yn;<br>    s=T;<br>    while(s-&gt;next!=NULL) {<br>        s=s-&gt;next;<br>    }<br>    do {<br>        p=(link)malloc(sizeof(struct node));<br>        printf(“请输入客户姓名：\n”);<br>        scanf(“%s”,p-&gt;data.name);<br>        printf(“请输入客户性别：\n”);<br>        scanf(“%s”,p-&gt;data.gender);<br>        printf(“请输入客户年龄：\n”);<br>        scanf(“%d”,&amp;p-&gt;data.age);<br>        printf(“请输入客户联系方式：\n”);<br>        scanf(“%s”,p-&gt;data.tel);<br>        p-&gt;next=NULL;<br>        s-&gt;next=p;<br>        s=p;<br>        if((fp=fopen(“1.txt”,”at”))==NULL) {<br>            printf(“write error!\n”);<br>            exit(0);<br>        }<br>        printf(“写了一次\n”);<br>        fprintf(fp,”%s\t%s\t%d\t%s\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel);<br>        if(fclose(fp)) {<br>            printf(“can’t close the file!\n”);<br>            exit(0);<br>        }<br>        printf(“添加成功!\n”);<br>        printf(“是否继续添加请输入0或1:”);<br>        scanf(“%d”,&amp;yn);<br>    } while(yn);<br>}<br></pre><br>代码逻辑很简单，新增结点，并连在尾节点后面，同时写入文件，如果前一片代码看懂了，这不是什么<br>大问题…     </p><p>###三、删除客户<br>代码如下</p><p><pre name="code" class="c++"><br>//删除<br>int del() {<br>    link p,q;<br>    FILE *fp;<br>    char mod[25];<br>    printf(“请输入需要删除的客户名称:\n”);<br>    scanf(“%s”,mod);<br>    p=T;<br>    while(p-&gt;next!=NULL&amp;&amp;strcmp(p-&gt;next-&gt;data.name,mod)!=0)<br>        p=p-&gt;next;<br>    if(p-&gt;next==NULL) {<br>        printf(“并无此人！\n”);<br>        return 0;<br>    }<br>    q = p;<br>    p = p-&gt;next;<br>    q-&gt;next = p-&gt;next;<br>    delete(p);<br>    printf(“删除成功！\n”);<br>    if((fp=fopen(“1.txt”,”wt”))==NULL) {<br>        printf(“error!\n”);<br>        exit(0);<br>    }<br>    p=T-&gt;next;<br>    while(p!=NULL) {<br>        printf(“%s”,p-&gt;data.name);<br>        fprintf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel);<br>        p = p-&gt;next;<br>    }<br>    if(fclose(fp)) {<br>        printf(“can’t close the file!\n”);<br>        exit(1);<br>    }<br>}<br></pre><br>模块三、四、五、六道理类似，不再赘述<br>附上代码地址：<br><a href="https://github.com/inspurer/DataStructure/tree/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/day01%E5%8D%95%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">github</a> 欢迎star<br>如有疑问，欢迎进群讨论：<br><img src="https://shang.qq.com/wpa/qunwpaidkey=206e0bc6e1608678ffccd929ba75b1a459994d2b638d3253df444ffcfd4964d9" alt="加群链接"><br>如链接失效，扫二维码：<br><img src="https://i.imgur.com/fEXzOCG.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今天起开始数据结构系列的分享，今天分享的是单链表。
    
    </summary>
    
      <category term="数据结构" scheme="https://inspurer.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表" scheme="https://inspurer.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端入门第二天</title>
    <link href="https://inspurer.github.io/2018/08/17/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>https://inspurer.github.io/2018/08/17/前端入门第二天/</id>
    <published>2018-08-17T11:43:04.000Z</published>
    <updated>2018-11-13T14:59:07.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>许久未更新了，今天七夕，为了逃避现实，重启博客。<a id="more"></a><br>本博客主要记录一些前端学习中的入门级问题。   </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Q1：HTML标签、元素、属性都是什么概念？"><a href="#Q1：HTML标签、元素、属性都是什么概念？" class="headerlink" title="Q1：HTML标签、元素、属性都是什么概念？"></a>Q1：HTML标签、元素、属性都是什么概念？</h2><p>HTML标签：HTML标签标记了HTML文档和HTML元素，HTML标签由开始标签和结束标签组成.<br>开始标签为尖括号包围的元素名,结束标签为尖括号包围的斜杠和元素名。<br>例如:<code>&lt;h2&gt; My First Heading&lt;/h2&gt;</code>  </p><p>HTML元素：HTML文档是由html元素定义的.<br>HTML的元素是指从开始标签到结束标签的所有代码..例如:<code>&lt;p&gt;我是一个段落&lt;/p&gt;</code>表示一个html元素.<br>可以看出,html元素主要包括html标签和纯文本.标签定义网页显示的格式,文本表示网页的内容.<br>故此,网页 =  html文档,而html文档则是由html元素定义的.   </p><p>HTML属性：<br>HTML属性为HTML元素提供附件信息,例如在超链接标签<code>&lt;a href = “https://inspurer.github.io&gt;月小水长的个人博客&lt;/a&gt;</code><br>使用了href属性来指定超链接的地址.<br>属性总是以名称/值的形式出现,例如:name = “value”<br>属性总是在开始标签中定义.   </p><h2 id="Q2：meta标签都用来做什么的？"><a href="#Q2：meta标签都用来做什么的？" class="headerlink" title="Q2：meta标签都用来做什么的？"></a>Q2：meta标签都用来做什么的？</h2><p><meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。   </p><p><meta> 标签位于文档的头部，不包含任何内容。<meta> 标签的属性定义了与文档相关联的名称/值对。   </p><h2 id="Q3：-Web语义化是什么，是为了解决什么问题？"><a href="#Q3：-Web语义化是什么，是为了解决什么问题？" class="headerlink" title="Q3： Web语义化是什么，是为了解决什么问题？"></a>Q3： Web语义化是什么，是为了解决什么问题？</h2><p>简言之，web语义化的目的是提高计算机和人对web代码的可读性。</p><p>网上的解释很多，个人总结分三个阶段比较容易理解。<br>1、原始的一些有实际含义的标签定义。浏览器和W3C组织推出的如h1~h6、thead、ul、ol<br>的HTML标签用于在Web页面中组织对应的内容，如网页标题、表头、无序、有序列表，<br>以达到更方便的协作及传播互联网内容的目的。搜索引擎很好的利用了这些语义化标签抓取<br>内容，又鉴于搜索引擎的巨大流量推荐，Web前端不得不考虑SEO，从而两者实现有益的<br>循环，共同推进着语义化标签的使用。</p><p>2、前端开发人员自定义的标签。但Web的发展超乎想象，起初定义的HTML语义化标签，<br>不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的<br>id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer<br>“或者class=”footer”的属性（值），以“无声”的方式  在不同的前端程序员或者<br>前后端程序员间实现交流。</p><p>3、在第二步的推动下结合新技术出现的一些标签。W3C组织意识到了之前HTML版本的不足，<br>推出的HTML5进一步推进了Web语义化发展，采用了诸如footer、section等语义化标签，<br>弥补了采用id=”footer”或者class=”footer”形式的不足，以更好的推动Web的发展。<br>正所谓：世上本没有路，走的人多了，也便成了路。    </p><h2 id="Q4-表单标签都有哪些，对应着什么功能，都有哪些属性"><a href="#Q4-表单标签都有哪些，对应着什么功能，都有哪些属性" class="headerlink" title="Q4: 表单标签都有哪些，对应着什么功能，都有哪些属性?"></a>Q4: 表单标签都有哪些，对应着什么功能，都有哪些属性?</h2><p>还是W3School的这篇教程经典：<a href="http://www.w3school.com.cn/html/html_form_input_types.asp" target="_blank" rel="noopener">HTML表单标签之input</a></p><h2 id="Q5-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方-举个例子"><a href="#Q5-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方-举个例子" class="headerlink" title="Q5: ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方?举个例子."></a>Q5: ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方?举个例子.</h2><p>1.无序列表<br>无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。<br>无序列表始于 <code>&lt;ul&gt;</code>标签。每个列表项始于 <code>&lt;li&gt;</code>。<br><img src="https://i.imgur.com/b6R182y.jpg" alt="">   </p><p>2.有序列表<br>同样，有序列表也是一列项目，列表项目使用数字进行标记。<br>有序列表始于 <code>&lt;ol&gt;</code>标签。每个列表项始于<code>&lt;li&gt;</code> 标签。<br>`<ol>  </ol></p><p><li>Coffee</li>   </p><p><li>Milk</li>  </p><p><ol>`<br>浏览器显示如下<br><img src="https://i.imgur.com/IW5e7G1.png" alt=""></ol></p><p>3.定义列表<br>自定义列表不仅仅是一列项目，而是项目及其注释的组合。<br>自定义列表以 <code>&lt;dl&gt;</code>标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。<br>每个自定义列表项的定义以<code>&lt;dd&gt;</code> 开始。<br><img src="https://i.imgur.com/DLDdGKN.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;许久未更新了，今天七夕，为了逃避现实，重启博客。
    
    </summary>
    
      <category term="前端" scheme="https://inspurer.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://inspurer.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端入门杂记</title>
    <link href="https://inspurer.github.io/2018/06/12/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E6%9D%82%E8%AE%B0/"/>
    <id>https://inspurer.github.io/2018/06/12/前端入门杂记/</id>
    <published>2018-06-12T15:58:24.000Z</published>
    <updated>2018-11-13T14:51:38.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从今天开始在本教程上纪录当日学到的知识点，不追求百科全书式的纪录<a id="more"></a>只记录<br>那些我比较陌生的或者觉得比较容易混淆的   </p><h1 id="笔记正文"><a href="#笔记正文" class="headerlink" title="笔记正文"></a>笔记正文</h1><ol><li>先来纪录一个坑，用notepad++写出第一个html文档时，代码如下<br><img src="https://i.imgur.com/vuyKm1V.png" alt=""><br>保存为html文件，在火狐浏览器打开，发现<code>文档的内容</code>这几个字是乱码<br>不是utf-8/cp36的问题，而是必须这个html文档必须要<code>BOM头</code>  </li><li>太累了，后续更新…2018/6/13深夜    </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从今天开始在本教程上纪录当日学到的知识点，不追求百科全书式的纪录
    
    </summary>
    
      <category term="前端" scheme="https://inspurer.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://inspurer.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端入门第一天</title>
    <link href="https://inspurer.github.io/2018/06/11/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://inspurer.github.io/2018/06/11/前端入门第一天/</id>
    <published>2018-06-11T15:40:05.000Z</published>
    <updated>2018-11-13T14:50:38.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前不久在网上看到一篇Hexo建站的教程，顺手给自己建了个<a href="https://inspurer.github.io/">个人博客</a>  <a id="more"></a><br>有还算扎实的c++/java/python/andorid基础，整个建站过程还算顺利<br>从此沉迷web编程,但是我感觉用现成的框架,总有点那啥受制于人的感觉<br>打算好好学一下前端，由于在实验室跟着老师做项目一直没有时间<br>但是万万没想到，心心念念的前端，开始正式开始系统学习居然是在忙到炸的期末考试周<br>在此要先pick一下<a href="http://ife.baidu.com/college/detail/id/5" target="_blank" rel="noopener">百度前端技术学院</a>,可以说是我的前端入门导师了哈哈哈，不bb了，<br>正式开始。  </p><h1 id="首先我们要知道访问网站的具体过程"><a href="#首先我们要知道访问网站的具体过程" class="headerlink" title="首先我们要知道访问网站的具体过程"></a>首先我们要知道访问网站的具体过程</h1><p>比如，输入<code>http://www.zhihu.com/question/22689579</code><br>访问过程如下图所示<br><img src="https://i.imgur.com/v0DfIHf.jpg" alt=""><br>浏览器和服务器交流，服务器和数据库交流（有时候数据库就在服务器那台机子上）<br>浏览器给服务器发一个请求，服务器不是一看就知道怎么响应的。<br>首先这些请求和响应要有一个通用的写法，也就是要有一个协议，常用的是<code>HTTP</code>协议。<br>像最前面的图，服务器的响应写了一个状态码<code>200 OK</code>,是<code>HTTP</code>协议里约定俗成的一个东西，<br>服务器写<code>200 OK</code>在响应里，表示“你请求的这个东西我有”，<br>如果是<code>404 Not Found</code>，就是“你请求的这个东西我这里没有”。<br><code>HTTP</code>响应里还包括很多东西，比如<code>Content-type</code>表示服务器发过来的文件类型是什么（文本？动画？图片？音频？）<br>形象化<code>Http</code>响应，大概这样：<br><img src="https://i.imgur.com/1D8LY96.jpg" alt="">  </p><h1 id="然后我们来了解前端三剑客"><a href="#然后我们来了解前端三剑客" class="headerlink" title="然后我们来了解前端三剑客"></a>然后我们来了解前端三剑客</h1><ol><li><strong>html</strong> 接上图，服务器返回html（就是上图HTTP响应的body里的内容)文件  后,电脑拿到<code>html</code>后，浏览器就会对它进行解析渲染，html是一种文本标记语言，举个栗子：<br><img src="https://i.imgur.com/XkEMXvx.jpg" alt="">  </li><li><strong>css</strong> 浏览器拿到这些代码之后，分析一下给你渲染好页面显示出来，<br>但是如果没有用css，效果是这样的，按照浏览器默认的样式显示<br>出列表、图片、超链接、输入框、按钮等等：<br><img src="https://i.imgur.com/rsWvX0a.jpg" alt=""><br>是不是觉得默认样式有点看瞎狗眼呢……所以很多时候我们需要自定义样式，<br>现行通用的规定样式的语言是CSS，我们可以用它写一些定义样式的代码，<br>在 html 文件里用一个<link>标签把这些规定样式的CSS代码与表达内容语义的HTML代码关联起来，<br>然后你就能看到一个符合人类正常审美的页面了:<br><img src="https://i.imgur.com/uXBaWo1.jpg" alt=""><br>插一句：CSS 代码的格式基本是<br><code>属性 : 值</code></li><li><strong>javascipt(js)</strong>有了表示内容和语义的 HTML，规定样式的 CSS，<br>得到的是一个静态的页面，没什么动画（其实用 CSS 还是可以有一些动画的,不过这个跑题了),<br>按 F5 才会刷新数据，于是我们有了 Javascript(js)来给页面添加一些动态的效果<br>浏览器都会帮你实现一些 JS 可以用的工具（函数，对象什么的），<br>你只要写一些js的代码，保存在xxx.js 里，在html文件中用 <code>&lt;script&gt;</code>关联进来就可以用了</li><li>在前端三剑客bb了怎么多，可以用一句很形象的话来归纳之：<br><code>前台三剑客，html是名词，css是形容词，javascript是动词。三个互相配合才是一句子</code><br>就问形不形象   <h1 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h1>考虑到三周的期末周，就立一个这样的flag吧：<br>暑假每天至少学习前端两个小时，争取下学期开始学完！  <h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1>最后实名pick一下小姐姐<a href="https://www.zhihu.com/question/22689579/answer/22318058" target="_blank" rel="noopener">张秋怡</a>,<br>感谢她的精彩回答<br>我只是个搬运工<br>只不过经过自己的理解稍作了修改<br>2018/6/12 00:31初稿<br>欢迎评论啊  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前不久在网上看到一篇Hexo建站的教程，顺手给自己建了个&lt;a href=&quot;https://inspurer.github.io/&quot;&gt;个人博客&lt;/a&gt;
    
    </summary>
    
      <category term="前端" scheme="https://inspurer.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://inspurer.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>”月小水长“和“inspurer”的由来</title>
    <link href="https://inspurer.github.io/2018/06/07/%E6%9C%88%E5%B0%8F%E6%B0%B4%E9%95%BF%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>https://inspurer.github.io/2018/06/07/月小水长的由来/</id>
    <published>2018-06-07T08:24:34.000Z</published>
    <updated>2018-11-12T13:23:19.747Z</updated>
    
    <content type="html"><![CDATA[<p> 非凭空臆想,其有典故；宋苏轼在后赤壁赋有云：<code>山高月小，水落石出曾日月之几何，而江山不可复识矣</code><a id="more"></a><br>在此我引申出<code>月小水长</code>句，一为不怕贻笑大方而附庸风雅，二为吾全名<code>肖涛</code>之字析，<code>月小</code>为<code>肖</code>，<code>水</code>即三点水，<code>长寿</code>为<code>涛</code>，还算是能够自圆其说。<br>至于<code>inspurer</code>,大一的时候了解到一家很厉害的中国企业<code>inspur浪潮</code><br>想不到中国除了<code>华为</code>还有在高新技术领域耕耘了这么深的企业，遂起名<br><code>inspurer</code>，寓意<code>弄潮儿</code>，想成为那种站在技术潮头的人儿呐~</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 非凭空臆想,其有典故；宋苏轼在后赤壁赋有云：&lt;code&gt;山高月小，水落石出曾日月之几何，而江山不可复识矣&lt;/code&gt;
    
    </summary>
    
      <category term="生活志" scheme="https://inspurer.github.io/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 实现自动化翻译和替换的脚本]]></title>
    <url>%2F2019%2F04%2F08%2FPython-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BF%BB%E8%AF%91%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[一个可能你似曾相识的场景阅读内容包含大量英文的 PPT、Word、Excel 或者记事本时，由于英语不熟悉，为了流利地阅读，需要打开浏览器进入谷歌翻译的主界面，然后把英文复制到谷歌翻译的输入框中，最后又把翻译结果复制回 PPT、Word 和 Excel。 要是一个两个单词还好，要是发现有 100 个单词不认识，就必须复制粘贴 200 次，如此机械性重复性的工作，应该交给程序来做，这就是我设计下面这个自动化翻译工具的初衷。 提升办公效率的法宝 如上图，运行程序并保持后台运行，在电脑上的任何一个软件中选择一段文本，并 Ctrl + C 复制到系统剪贴板中，程序就会自动帮助我们完成翻译，并将翻译结果自动复制到系统剪贴版中，只需 Ctrl + V，就完成了翻译结果对原文的替换。 编码实现程序主要分为两部分，第一部分为谷歌翻译爬虫，第二部分就是实现这个将翻译结果自动替换的业务逻辑。 谷歌翻译爬虫通过浏览器 F12 开发者工具，很容易定位到翻译请求的 URL: http://translate.google.cn/translate_a/single?client=t&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=ss &amp;dt=t&amp;ie=UTF-8&amp;oe=UTF-8&amp;clearbtn=1&amp;otf=1&amp;pc=1&amp;srcrom=0&amp;ssel=0&amp;tsel=0&amp;kc=2 这个请求接受两个参数，一个就是我们要翻译的字符串 q，另一个是用于用户认证的 tk(token),其中 q 很容易构造，tk 的构造就需要花费一番心力了，需要我们调试 js 代码，这里参考 Github 上大神的轮子： https://github.com/cocoa520/Google_TK 谷歌翻译爬虫的主要代码如下: def translate(tk, content): if len(content) &gt; 4891: print(&quot;翻译的长度超过限制！！！&quot;) return param = {&apos;tk&apos;: tk, &apos;q&apos;: content} result = requests.get(&quot;&quot;&quot;http://translate.google.cn/translate_a/single?client=t&amp;sl=en &amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=ss &amp;dt=t&amp;ie=UTF-8&amp;oe=UTF-8&amp;clearbtn=1&amp;otf=1&amp;pc=1&amp;srcrom=0&amp;ssel=0&amp;tsel=0&amp;kc=2&quot;&quot;&quot;, params=param) data = result.json() print(data[0][0][0]) 返回结果是 json 形式的，翻译结果保存在结果的第一个元组中。 Python 操作系统剪贴板将读取剪贴板的内容的代码封装成函数如下： def getText():#读取剪切板 # 打开剪贴板 w.OpenClipboard() # 读取剪贴板的内容 d = w.GetClipboardData(win32con.CF_TEXT) # 关闭剪贴板 w.CloseClipboard() try: return d.decode(&apos;utf-8&apos;) except: return d.decode(&apos;gbk&apos;) 返回值 d 是字节类型的，需要解码，中文按 gbk 格式解码，英文按 utf-8 解码。 类似地，写入剪贴板的代码如下： def setText(aString):#写入剪切板 # 打开剪贴板 w.OpenClipboard() # 清空剪贴板 w.EmptyClipboard() # 写入剪贴板 w.SetClipboardText(aString) # 关闭剪贴板 w.CloseClipboard() 实现将翻译结果自动替换原文的逻辑的代码如下： while(True): # 如果剪贴板正在被占用 try: cs = getText() except: time.sleep(1) cs = getText() print(&apos;cs&apos;,cs) if cs and cs != ls: print(&apos;准备翻译&apos;) content = getText() tk = js.getTk(content) res = translate(tk, content) setText(res) time.sleep(1) ls = res 值得注意的是，系统剪贴板对象是单例模式的，在操作系统范围内只有一个，而且读写剪贴板都是互斥的，在读（写）剪贴板的同时不允许任何对剪贴板的写（读）操作。试想这样一种情景，我们在其他软件中 Ctrl + C 写入剪贴板，而此时我们的程序代码正好执行到读剪贴板那一行，毫无疑问会报错，我的解决办法是使用 try…except 语句延时 1 s再读取，这样可以大大降低读写碰撞的概率，但无疑消耗了程序性能。最好的办法是判断剪贴板对象句柄是否被占用，其实我一直在寻找是否存在判断剪贴板对象句柄是否被占用的 API,但是一直没有找到，如果有人知道的话，欢迎评论区留言。 源代码获取关注公众号 月小水长，后台回复，自动替换的翻译软件 即可获取所有源代码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>谷歌翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice NO.1002]]></title>
    <url>%2F2019%2F03%2F23%2FPAT-Advanced-Level-Practice-NO-1002%2F</url>
    <content type="text"><![CDATA[Question1002 A+B for Polynomials （25 分)This time, you are supposed to find A+B where A and B are two polynomials.Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ … N​K​​ a​N​K​​​​ where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N​K​​&lt;⋯&lt;N​2​​&lt;N​1​​≤1000.Output Specification: For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:2 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:3 2 1.5 1 2.9 0 3.2 Solutionimport java.util.*; //CreateTime: 2019/3/21 23:21 //Author: 月小水长(https://github.com/inspurer) /* 类名:首字母大写，其他单词中首字母大写，其他小写 方法名:首字母小写，其他单词中首字母大写，其他小写 变量:与方法名规则同 包名:全部小写 */ public class Main { public static void main(String [] args){ Scanner sc = new Scanner(System.in); String aLine = null; String [] l = null; HashMap&lt;Integer,Float&gt; [] hm = new HashMap[2]; for(int i = 0; i &lt; 2; i++){ aLine = sc.nextLine(); l = aLine.split(&quot; &quot;); hm[i] = new HashMap&lt;Integer, Float&gt;(Integer.parseInt(l[0])); for(int j = 1; j &lt; l.length; j += 2){ hm[i].put(Integer.parseInt(l[j]),Float.parseFloat(l[j+1])); } } sc.close(); HashSet&lt;Integer&gt; setKeys = new HashSet&lt;&gt;(hm[0].keySet()); setKeys.addAll(hm[1].keySet()); ArrayList&lt;Integer&gt; sumKeys = new ArrayList&lt;&gt;(setKeys); HashMap&lt;Integer,Float&gt; res = new HashMap&lt;Integer,Float&gt;(); // 排除掉系数为 0 for(int i = 0; i &lt; sumKeys.size(); i++){ int key = sumKeys.get(i); float value = hm[0].getOrDefault(key,0.0f)+hm[1].getOrDefault(key,0.0f); if(value == 0.0f) continue; res.put(key,value); } ArrayList resultKeys = new ArrayList(res.keySet()); Collections.sort(resultKeys, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); // 如果项数为0，只把0输出就可以了 if(res.size() == 0) { System.out.print(0); return; } System.out.print(res.size()); System.out.print(&quot; &quot;); for(int i = 0; i &lt; resultKeys.size(); i++){ int key = (int)resultKeys.get(i); System.out.print(key); System.out.print(&quot; &quot;); System.out.printf(&quot;%.1f&quot;,res.get(key)); if(i == resultKeys.size() - 1) break; System.out.print(&quot; &quot;); } } } /* 格式错误，要求跟输入一样，浮点数保留一位小数，最后不能有空格 没有考虑到如果两个多项式相加，会出现系数为0的情况，此时不再记录（多虑的是demo分明有0输出了么，但是它是指数不是系数） 数据的类型，一定尽量开始就合适 */ CodePAT Advanced Pratice 题解系列代码集合]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice No.1001]]></title>
    <url>%2F2019%2F03%2F22%2FPAT-Advanced-Level-Practice-No-1001%2F</url>
    <content type="text"><![CDATA[Question001 A+B Format （20 分)Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).Input Specification: Each input file contains one test case. Each case contains a pair of integers a and b where −10​6​​≤a,b≤10​6​​. The numbers are separated by a space.Output Specification: For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:-1000000 9 Sample Output:-999,991 Solutionimport java.util.LinkedList; import java.util.Scanner; //CreateTime: 2019/3/21 23:21 //Author: 月小水长(https://github.com/inspurer) /* 类名:首字母大写，其他单词中首字母大写，其他小写 方法名:首字母小写，其他单词中首字母大写，其他小写 变量:与方法名规则同 包名:全部小写 */ public class Main { public static void main(String [] args){ Scanner scanner = new Scanner(System.in); int num1 = Integer.parseInt(scanner.next()); int num2 = Integer.parseInt(scanner.next()); scanner.close(); num1 += num2; int flag = num1&gt;=0?1:0; num1 = num1&gt;0?num1:-num1; if(String.valueOf(num1).length()&lt;4) { if (flag == 0) { System.out.print(-num1); } else { System.out.print(num1); } return; } LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); do{ result.add(String.valueOf(num1%10)); num1 /= 10; if((result.size()+1)%4==0&amp;&amp;num1&gt;0){ result.add(&quot;,&quot;); } }while (num1&gt;0); if(flag==0){ result.add(&quot;-&quot;); } for(int i = result.size()-1;i&gt;=0;i--) System.out.print(result.get(i)); } } ConclusionScanner.nextInt() 方法只能接收正整数，如输入负整数则会忽略掉掉负号，相当于对输入取 abs() ，要想解决这个 Bug，可以通过 1int num1 = Integer.parseInt(scanner.next()); 解决。 next() 和 nextLine() 都接收字符串；next() 方法一定要接收到有效字符串才可以结束输入，对输入有效字符之前遇到的空格键、Tab 键或回车键等，next() 方法会自动将其去掉，只有在输入有效字符之后，next() 方法才将其后输入的空格键、Tab 键或回车键视为分隔符或结束符；nextLine() 方法的结束符只是回车键，即 nextLine() 方法返回的是回车键的所有字符。 CodePAT Advanced Pratice 题解系列代码集合]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>scanner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Tensorflow构建自己的物体识别模型(一)]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%88%A9%E7%94%A8Tensorflow%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[原料windows10+python3.5+pycharm 安装tensorflow利用Tensorflow训练搭建自己的物体训练模型，万里长征第一步，先安装tensorflow。 tensorflow分为cpu版和gpu版，gpu版的运行速度是cpu的50倍，但是gpu版的坑太多，要安装许多开发套件,对windows的支持不够友好；更为致命的是,它需要Nvida的中高端显卡，我的电脑系统是windows10,显卡是入门级显卡，开始我还想挣扎一下，安装个gpu版，大概试了一个晚上，到底是没有成功，识时务者为俊杰，那就安装cpu版的吧。 pip insatll tensorflow 假如没有报错，做个测试，运行以下代码 import tensorflow as tf #指定一个常数张量 first_blood = tf.constant(&apos;double kill&apos;) #创建一个会话，方便查看结果 sess = tf.Session() print(str(sess.run(first_blood))) 运行结果如下 E:\python\python.exe &quot;E:/pycharm src/TF/__init__.py&quot; 2018-12-01 23:33:25.181550: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 double kill Process finished with exit code 0 如果出现警告: Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 翻译过来的大致意思是:你的CPU支持AVX扩展，但是你安装的TensorFlow版本无法编译使用 此时需要在第一行代码前加上两行代码: import os os.environ[&apos;TF_CPP_MIN_LOG_LEVEL&apos;] = &apos;2&apos; import tensorflow as tf # 指定一个常数张量 first_blood = tf.constant(&apos;double kill&apos;) # 创建一个会话，方便查看结果 sess = tf.Session() print(str(sess.run(first_blood))) 下载Tensorflow object detection API如果有git的话，右键git bash,使用命令下载： git clone https://github.com/tensorflow/models.git 或者直接打开网站: https://github.com/tensorflow/models 点击绿色按钮-&gt;downlaod zip 下载好之后，把文件解压，注意解压路径不要包含中文，比如我的解压后的路径是: C:\Users\lenovo\Desktop\note\gitclone\models 如果下载速度很慢，可以参考:https://blog.csdn.net/ygdxt/article/details/82825013 下载并配置protoc在https://github.com/google/protobuf/releases中选择windows版本： 只有win32,也就是windows32位的，64位是兼容32位的。 下载好之后，解压，把bin目录下的protoc.exe复制到..\models\research文件夹下。 接着就是配置protoc了，在打开cmd下切换到..\models\research目录， 执行命令protoc object_detection\protos\*.proto --python_out=. 如果报以下的错(其实很大可能性会报错，无论是不是在管理员模式下）： object_detection\protos*.proto: No such file or directory 则需要对指令做修改，指令protoc object_detection\protos\*.proto --python_out=.中的*.proto表示是对research目录下的所有后缀名为proto的文件做操作，那干脆我们把指令中的*.proto这部分改成所有后缀名为proto的文件，每执行一次，就会生成一个.py文件，由于文件太多，我已经把指令写成脚本: import os path_url = os.path.join(os.getcwd(),r&quot;object_detection\protos&quot;) print(&quot;proto path:&quot;,path_url) for file in os.listdir(path_url): cmd = &quot;protoc object_detection\protos\{} --python_out=.&quot; if file.endswith(&quot;.proto&quot;): command = cmd.format(file) print(&quot;excuting command:&quot;,command) os.popen(command) 在..\research目录下新建一个文件excuter.py,把以上代码复制进去，保存运行，稍等一会儿就可以看到..\research\object_detection\protos目录下生成了许多.py文件，说明protoc配置成功。 models环境变量配置配置环境变量依次打开：我的电脑—&gt;高级系统设置—&gt;环境变量，新建一个系统变量: 系统变量名只要不和已有的重复，符合命令规范，没有其他要求，我这里是tensorflow系统变量名下有两个值,..\research和..\research\slim的绝对路径。 测试在..\research下打开cmd，运行以下命令， python object_detection/builders/model_builder_test.py 如果出现错误: 报错原因是你的models路径太长，python无法找指定模块，解决办法是在你的python安装路径下新建一个tensorflow_model.pth文件(比如我的是E:\python\Lib\site-packages)把写到环境变量里的那两个路径复制到该文件中。 再运行命令python object_detection/builders/model_builder_test.py 说明配置成功 利用tensorflow自带模型测试测试的图片是在 C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\test_images 我们看到这里有现成的两张图片，当然也可以换成自己的。 测试的脚本是 C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\object_detection_tutorial.ipynb 这是一个需要用jupyter notebook打开的文件，不过好像在jupyter notebook运行会有许多毛病我已经把这个ipynb文件改写成py文件，并修复了一些未知问题，文件内容如下: import numpy as np import os import six.moves.urllib as urllib import sys import tarfile import tensorflow as tf import zipfile from distutils.version import StrictVersion from collections import defaultdict from io import StringIO from matplotlib import pyplot as plt from PIL import Image # This is needed since the notebook is stored in the object_detection folder. sys.path.append(&quot;..&quot;) from object_detection.utils import ops as utils_ops if StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;): raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;) import numpy as np import os import six.moves.urllib as urllib import sys import tarfile import tensorflow as tf import zipfile from distutils.version import StrictVersion from collections import defaultdict from io import StringIO from matplotlib import pyplot as plt from PIL import Image # This is needed since the notebook is stored in the object_detection folder. sys.path.append(&quot;..&quot;) from object_detection.utils import ops as utils_ops if StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;): raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;) from utils import label_map_util from utils import visualization_utils as vis_util # What model to download. MODEL_NAME = &apos;ssd_mobilenet_v1_coco_2017_11_17&apos; MODEL_FILE = MODEL_NAME + &apos;.tar.gz&apos; DOWNLOAD_BASE = &apos;http://download.tensorflow.org/models/object_detection/&apos; # Path to frozen detection graph. This is the actual model that is used for the object detection. PATH_TO_FROZEN_GRAPH = MODEL_NAME + &apos;/frozen_inference_graph.pb&apos; # List of the strings that is used to add correct label for each box. PATH_TO_LABELS = os.path.join(&apos;data&apos;, &apos;mscoco_label_map.pbtxt&apos;) opener = urllib.request.URLopener() opener.retrieve(DOWNLOAD_BASE + MODEL_FILE, MODEL_FILE) tar_file = tarfile.open(MODEL_FILE) for file in tar_file.getmembers(): file_name = os.path.basename(file.name) if &apos;frozen_inference_graph.pb&apos; in file_name: tar_file.extract(file, os.getcwd()) detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_FROZEN_GRAPH, &apos;rb&apos;) as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name=&apos;&apos;) category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS, use_display_name=True) def load_image_into_numpy_array(image): (im_width, im_height) = image.size return np.array(image.getdata()).reshape( (im_height, im_width, 3)).astype(np.uint8) # For the sake of simplicity we will use only 2 images: # image1.jpg # image2.jpg # If you want to test the code with your images, just add path to the images to the TEST_IMAGE_PATHS. PATH_TO_TEST_IMAGES_DIR = &apos;test_images&apos; TEST_IMAGE_PATHS = [ os.path.join(PATH_TO_TEST_IMAGES_DIR, &apos;image{}.jpg&apos;.format(i)) for i in range(1, 3) ] # Size, in inches, of the output images. IMAGE_SIZE = (12, 8) output_num = 1 output_img_dic = r&apos;\output_images&apos; def run_inference_for_single_image(image, graph): with graph.as_default(): with tf.Session() as sess: # Get handles to input and output tensors ops = tf.get_default_graph().get_operations() all_tensor_names = {output.name for op in ops for output in op.outputs} tensor_dict = {} for key in [ &apos;num_detections&apos;, &apos;detection_boxes&apos;, &apos;detection_scores&apos;, &apos;detection_classes&apos;, &apos;detection_masks&apos; ]: tensor_name = key + &apos;:0&apos; if tensor_name in all_tensor_names: tensor_dict[key] = tf.get_default_graph().get_tensor_by_name( tensor_name) if &apos;detection_masks&apos; in tensor_dict: # The following processing is only for single image detection_boxes = tf.squeeze(tensor_dict[&apos;detection_boxes&apos;], [0]) detection_masks = tf.squeeze(tensor_dict[&apos;detection_masks&apos;], [0]) # Reframe is required to translate mask from box coordinates to image coordinates and fit the image size. real_num_detection = tf.cast(tensor_dict[&apos;num_detections&apos;][0], tf.int32) detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1]) detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1]) detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks( detection_masks, detection_boxes, image.shape[0], image.shape[1]) detection_masks_reframed = tf.cast( tf.greater(detection_masks_reframed, 0.5), tf.uint8) # Follow the convention by adding back the batch dimension tensor_dict[&apos;detection_masks&apos;] = tf.expand_dims( detection_masks_reframed, 0) image_tensor = tf.get_default_graph().get_tensor_by_name(&apos;image_tensor:0&apos;) # Run inference output_dict = sess.run(tensor_dict, feed_dict={image_tensor: np.expand_dims(image, 0)}) # all outputs are float32 numpy arrays, so convert types as appropriate output_dict[&apos;num_detections&apos;] = int(output_dict[&apos;num_detections&apos;][0]) output_dict[&apos;detection_classes&apos;] = output_dict[ &apos;detection_classes&apos;][0].astype(np.uint8) output_dict[&apos;detection_boxes&apos;] = output_dict[&apos;detection_boxes&apos;][0] output_dict[&apos;detection_scores&apos;] = output_dict[&apos;detection_scores&apos;][0] if &apos;detection_masks&apos; in output_dict: output_dict[&apos;detection_masks&apos;] = output_dict[&apos;detection_masks&apos;][0] return output_dict for image_path in TEST_IMAGE_PATHS: image = Image.open(image_path) # the array based representation of the image will be used later in order to prepare the # result image with boxes and labels on it. image_np = load_image_into_numpy_array(image) # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image_np, axis=0) # Actual detection. output_dict = run_inference_for_single_image(image_np, detection_graph) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image_np, output_dict[&apos;detection_boxes&apos;], output_dict[&apos;detection_classes&apos;], output_dict[&apos;detection_scores&apos;], category_index, instance_masks=output_dict.get(&apos;detection_masks&apos;), use_normalized_coordinates=True, line_thickness=8) plt.figure(figsize=IMAGE_SIZE) print(1,image_np) plt.imshow(image_np) plt.show() global output_num global output_img_dic if not os.path.exists(output_img_dic): os.mkdir(output_img_dic) output_img_path = os.path.join(output_img_dic,str(output_num)+&quot;.png&quot;) plt.savefig(output_img_path) 运行上述代码需要安装matplotlib库，直接pip install matplotlib安装失败的可以去官网安装与python版本对应的whl文件。安装matplotlib.whl时需要先出pycharm。同时由于需要下载模型文件，需要在网络好的情况下进行测试。否则就会报HTTP ERROR 运行效果图 声明以上就是本次教程的所有内容，后续还会有系列教程，原创作品，转载请联系2391527690@qq.com欢迎大家多多上机操作，指出本教程的不足之处，如有问题，可加群交流，群号码: 861016679本文首发于我的简书，如果您在本站上看到了google广告，请多多点击，算是对我的一个鼓励，能够赞赏那就更好了，谢谢！]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文搞定python的时间处理]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Apython%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[如果认真看完这篇文章你还不知道怎么处理python的时间问题，你可以来diss我 time模块# -*- coding: utf-8 -*- # author: inpurer(月小水长) # pc_type lenovo # create_date: 2018/12/3 # file_name: timetest.py # description: 月小水长，热血未凉 import time t0 = time.time() #description: 输出当前时间距离1970.1.1的秒数,精确到小数点后6位，也叫做时间戳 #output sample: 1543799532.602318 print(t0) t1 = time.localtime(t0) #description: 把时间戳转成元组,包含七个元素,前六个见名知意,tm_wday是指今天是当前周的第几天(index from 0),tm_yday类似,tm_isdst是否是夏令时,不用关心 #output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=22, tm_sec=24, tm_wday=0, tm_yday=337, tm_isdst=0) print(t1) #so,可以这样输出今天是今年的第多少天 print(t1[-2]+1) #下面是对该元组的格式化 #description: 简单可读形式 #output sample: Mon Dec 3 09:31:18 2018 t2 = time.asctime(t1) print(t2) #description: 可通过参数设置成各种形式，下面是一种标准形式,各参数见名知意 #output sample: 2018-12-03 09:33:36 t3 = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t1) print(t3) #%y 两位数的年份表示（00-99） # %Y 四位数的年份表示（000-9999） # %m 月份（01-12） # %d 月内中的一天（0-31） # %H 24小时制小时数（0-23） # %I 12小时制小时数（01-12） # %M 分钟数（00=59） # %S 秒（00-59） # # %a 本地简化星期名称 # %A 本地完整星期名称 # %b 本地简化的月份名称 # %B 本地完整的月份名称 # %c 本地相应的日期表示和时间表示 # %j 年内的一天（001-366） # %p 本地A.M.或P.M.的等价符 # %U 一年中的星期数（00-53）星期天为星期的开始 # %w 星期（0-6），星期天为星期的开始 # %W 一年中的星期数（00-53）星期一为星期的开始 # %x 本地相应的日期表示 # %X 本地相应的时间表示 # %Z 当前时区的名称 # %% %号本身 # 下面是把格式化字符串转成元组 # description: 第一个参数个格式化后的字符串,后一个参数和格式化对应，便于反格式化 # output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=47, tm_sec=7, tm_wday=0, tm_yday=337, tm_isdst=-1) t4 = time.strptime(t3,&apos;%Y-%m-%d %H:%M:%S&apos;) print(t4) # 把元组转成时间戳 #description: 是time.localtime的反函数,不过由于格式化的原因，精度有所下降 #output sample: 1543801627.0 t5 = time.mktime(t4) print(t5) datetime模块# -*- coding: utf-8 -*- # author: inpurer(月小水长) # pc_type lenovo # create_date: 2018/12/3 # file_name: timetest.py # description: 月小水长，热血未凉 import datetime #通过datetime.datetime.now()可以获得当前日期时间的一个实例 #这个实例是一个datetime类对象而不是字符串 #虽然直接打印该实例输出的是一个字符串,只是调用datetime实现的__str__方法而已 t0 = datetime.datetime.now() print(t0) #print: 2018-12-03 12:55:49.905971 print(type(t0)) #print: &lt;class &apos;datetime.datetime&apos;&gt; #然后就可以通过对象名.的方法输出各个时间信息,该信息是一个int类型 print(t0.year) #print: 2018 print(type(t0.year)) #print: &lt;class &apos;int&apos;&gt; print(t0.month) print(t0.day) print(t0.hour) print(t0.minute) print(t0.second) 时间的存储，比较存储理论上我们可以通过拼接datetime.datetime.now()实例的各个时间变量来构建我们自己的想要时间,例如我们想要存储year-month-day这样的时间信息，我们可以这样做: import datetime t0 = datetime.datetime.now() #注意year/month/day都是int类型，不像java那样可以直接拼接字符串和数字 wanted_time = str(t0.year)+&quot;-&quot;+str(t0.month)+&quot;-&quot;+str(t0.day) 但是，这样做会有非常尴尬的问题:格式不统一，可能会出现下面这样的存储形式： 2018-1-12018-1-112018-11-12018-11-11…………….. 特别是在数据量非常庞大的时候，阅读起来非常费力，这是因为year/month/day这些都是int型，所以1就是1，不会显示成01,要实现对齐效果，必须还得字符串的格式化，所以，我们通常用的是time模块(其实datetime也有字符串的格式化，不过展开讲就太多了，不必要浪费这么多学习成本) import time t0 = time.localtime() wanted_time = time.strftime(&quot;%Y-%m-%d&quot;,t0) 比较就拿上面刚刚说的wanted_time来说，可以直接通过&gt;、=、&lt;这些符号来比较，因为wanted_time就是一个字符串。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现微信自动回复和群聊助手]]></title>
    <url>%2F2018%2F12%2F01%2FPython%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%92%8C%E7%BE%A4%E8%81%8A%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[本文首发于我的简书https://www.jianshu.com/p/4b7b4f4fb0e4 本教程的作用零基础手把手教你打造一款微信机器人，包括好友聊天自动回复和群聊助手两个部分，零基础！话不多说，下面开始实战编码。 第一部分:好友聊天自动回复第一步，安装python环境。打开python官网https://www.python.org/downloads/，下载与你的电脑系统相匹配的python发行版本，推荐python3.5-python3.6,版本太高了可能有许多未知的bug，太低了兼容性不太好。 第二步，安装itchat库在命令行下输入pip install itchat完成安装 第三步，编写代码核心代码如下： #coding=utf8 import itchat # 当接收到的消息是Text，即文字消息 #注册re_msg的意义在于，告诉itchat每次有符合特定条件的消息，itchat要把消息作为参数，去调用re_msg。 @itchat.msg_register(&apos;Text&apos;) def text_reply(msg): #message:取出msg里面的文本消息 message = msg[&apos;Text&apos;] # 回复给好友 replay = u&apos;肖涛已在电脑上登陆网页微信，但暂时无法进行交流,可以给他发送电脑QQ消息哈&apos; #主要是一些关键词设置 # if B in A 如果 A中有B的话 if u&apos;干什么&apos; in message: replay = u&apos;在忙呢&apos; elif u&apos;逼&apos; in message: replay = u&apos;含有敏感词汇,请注意言辞&apos; elif u&apos;生气&apos; in message: replay = u&apos;生气对身体不好&apos; elif u&apos;?&apos; in message: replay = u&apos;哈哈，我也不知道&apos; elif u&apos;不理你&apos; in message: replay = u&apos;乖，忙完给你买糖吃&apos; elif u&apos;涛&apos; in message: replay = u&apos;他是我主人&apos; elif u&apos;厉害&apos; in message: replay = u&apos;不不不，辣鸡一个&apos; elif u&apos;你好&apos; in message: replay = u&apos;你好哇&apos; elif u&apos;好吧&apos; in message: replay = u&apos;再见&apos; return replay #弹出扫码登录界面,参数这样设置的好处是短时间内退出程序，再次登录可以不用扫码 itchat.auto_login(hotReload=True) #开启自动回复 itchat.run() 以上代码都是本人亲自编写，如需转载请私信我。代码截至2018/11/30本人调试有效，最新的代码更新在我的github：auto_replay.py如有问题欢迎评论。 运行代码运行之后，会弹出一个二维码，用微信扫一扫登录网页版微信之后，这份代码就会接管你的消息通知。下面是一个简单的效果图 第二部分：群聊助手第一步是点对点的消息自动回复，本部分实现的是点对多、在群中的消息自动回复。请确认上一部分实现无误之后再来尝试第二部分，因为第二部分需要第一部分的环境配置做支撑。 编写代码 import itchat import requests def get_response(msg): apiUrl = &apos;http://www.tuling123.com/openapi/api&apos; #改成你自己的图灵机器人的api &apos;key&apos;: &apos;ce697b3fc8b54d5f88c2fa59772cb2cf&apos;, # Tuling Key &apos;info&apos;: msg, # 这是我们发出去的消息 &apos;userid&apos;: &apos;wechat-robot&apos;, # 这里可随意修改 } # 通过如下命令发送一个post请求 r = requests.post(apiUrl, data=data).json() return r.get(&apos;text&apos;) @itchat.msg_register(itchat.content.TEXT) #用于接收来自朋友间的对话消息 #如果不用这个，朋友发的消息便不会自动回复 def print_content(msg): return get_response(msg[&apos;Text&apos;]) #用于接收群里面的对话消息 @itchat.msg_register([itchat.content.TEXT], isGroupChat=True) def print_content(msg): return get_response(msg[&apos;Text&apos;]) itchat.auto_login(True) itchat.run() 接入图灵机器人打卡图灵机器人官网，http://www.tuling123.com/,注册账号，新建一个机器人，如下图把图中的apikey替换到代码里就行，如果你要用我的，我也无法拒绝，毕竟我的apikey也贴出来了。 运行效果 简要原理一但接收到信息，就会调用get_response()方法，把消息传给图灵机器人，然后图灵机器人把回复信息再返回给微信。 截至2018/11/30代码运行无误，最新更新在我的github：grouphandler.py如有问题请评论，如需转载请私信我。 后记本篇文章参考了我的两篇csdn博客https://blog.csdn.net/ygdxt/article/details/79766197https://blog.csdn.net/ygdxt/article/details/81101020在这里推荐两个python代码仓库：一个是PythonLearning,这里面有我学习python的课程学习资料、以及一些我实战编写的代码，另一个是PythonSpider,这里面主要是一些我写的python实现的爬虫。更多的请访问我的github，欢迎star，fork.另外欢迎关注微信公众号：inspurer 如果你觉得本篇文章不错，不妨打赏一下，谢谢。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取学校教务系统]]></title>
    <url>%2F2018%2F11%2F30%2Fpython%E7%88%AC%E5%8F%96%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[写这个爬虫的缘由以前用java写过一个爬取学校的教务系统的爬虫 https://blog.csdn.net/ygdxt/article/details/81158321，最近痴迷Python爬虫，了解到许多强大的库，想再一次用学校的教务系统做下测试。这一次我首先想到的是新的教务系统，这个难度更大，因为有了验证码识别反爬，由于我是用的tessocr库识别验证码,(具体配置过程可以参考我之前的博客 python填坑之路:tesserocr配置)用Requests.get方法把验证码下载下来识别之后，同时因为我爬取网页是用的selenium做的模拟网页动作，这里就有一个同步性的问题，不能保证selenium请求网页上的验证码和requests请求的验证码是同一个，相当于selenium、requests分别请求了一次登陆网页，两个网页上的验证码显然是不同的。所以 怎么保证请求登录界面得到的网页上的验证码 和我们请求验证码服务器返回的验证码是同一个验证码是同一个是一个很迷人的问题， 我开始还以为可以从网页源代码上直接定位到这个验证码，结果显示这个验证码在登录界面的 的存在形式不是一个..png/jpg,而是通过src=“验证码服务器”来实现异步加载 同时，由于tessocr识别验证码的成功率可能只有50%，要提高验证率可能还要对接云打码，果断放弃了爬取新教务系统的想法，还是爬取原来的没有验证码的旧教务系统，其实新旧教务系统最大的区别就是登陆界面不一样，登陆之后都一样，貌似用了重定向ps:如果你对这个问题有什么好的解决办法，请不吝赐教 编码过程详细的代码解释就看注释吧，有什么问题欢迎交流 执行爬虫的主程序csu.py，里面有许多测试用的注释代码，就不删了from selenium import webdriver from selenium.webdriver.common.by import By from selenium.common.exceptions import TimeoutException from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.support.select import Select from config import * import time broswer = webdriver.Chrome() wait = WebDriverWait(broswer, 10) def search(): try: broswer.get(&quot;http://csujwc.its.csu.edu.cn/jsxsd/kscj/yscjcx_list&quot;) account = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userAccount&quot;)) ) password = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userPassword&quot;)) ) submit = wait.until( EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#btnSubmit&quot;)) ) except TimeoutException: return search() #登录 account.send_keys(ACCOUNT) password.send_keys(PASSWORD) submit.click() #进入我的成绩界面 my_score = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR,&quot;body &gt; div.wap &gt; a:nth-child(3) &gt; div&quot;)) ) my_score.click() #成绩和平均分 # my_rank = wait.until( # EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(4) &gt; a&quot;)) # ) # my_rank.click() # # rank = wait.until( # EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(3)&quot;)) # ) # #http://www.w3school.com.cn/cssref/selector_nth-child.asp nth-child(n)的用法 # average_score = wait.until( # EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(4)&quot;)) # ) # # print(&apos;您的平均成绩是:&apos;+average_score.text+&quot;\n排名:&quot;+rank.text) #逐次展示 我的成绩八个子项 # css_selector = &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child({0}) &gt; a&quot; # for i in range(8): # # 将滚动条移动到页面的顶部 # js = &quot;var q=document.documentElement.scrollTop=0&quot; # broswer.execute_script(js) # time.sleep(2) # # aviable_score = wait.until( # EC.presence_of_element_located((By.CSS_SELECTOR, css_selector.format(str(i+1)))) # ) # aviable_score.click() # # # #将滚动条移动到页面的底部 # for j in range(8): # js=&quot;var q=document.documentElement.scrollTop=&quot;+str(j*200) # broswer.execute_script(js) # time.sleep(1) #处理select https://www.cnblogs.com/imyalost/p/7846653.html yxcj = wait.until( EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(1) &gt; a&quot;)) ) select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;) select_score = Select(select_score_element) #得到下拉列表的所有子项 select_score_items = broswer.find_elements_by_css_selector(&quot;#xnxq01id option&quot;) select_score_items_text = [] for item in select_score_items: select_score_items_text.append(item.text) #print(item.text) scores_dic = {} for i in range(len(select_score.options)): #不加这两行会报错，原因： https://blog.csdn.net/ulebo/article/details/52128033 print(&quot;*****************************************************&quot;+select_score_items_text[i]+ &quot;*****************************************************&quot;) select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;) select_score = Select(select_score_element) select_score.select_by_index(i) time.sleep(1) score_table = broswer.find_element_by_css_selector(&quot;#dataList&quot;) data = score_table.text.replace(&quot;+&quot;,&quot;&quot;) data = data.split(&quot;\n&quot;) datalist = [] for line in data: datalist.append(line.split()) scores_dic[select_score_items_text[i]] = datalist return scores_dic[select_score_items_text[0]] def main(): search() if __name__ ==&quot;__main__&quot;: main() ui.py程序的gui，直接运行这个就好，它会调用csu.py #coding=utf-8 import wx import wx.grid import csu class UI(wx.Frame): def __init__(self): wx.Frame.__init__(self,parent=None,title=&quot;成绩查询&quot;,size=(1050,560)) grid = wx.grid.Grid(self,pos=(10,0),size=(1050,500)) grid.CreateGrid(100,9) for i in range(100): for j in range(9): grid.SetCellAlignment(i,j,wx.ALIGN_CENTER,wx.ALIGN_CENTER) grid.SetColLabelValue(0, &quot;序号&quot;) #第一列标签 grid.SetColLabelValue(1, &quot;初修学期&quot;) grid.SetColLabelValue(2, &quot;获得学期&quot;) grid.SetColLabelValue(3, &quot;课程&quot;) grid.SetColLabelValue(4, &quot;成绩&quot;) # 第一列标签 grid.SetColLabelValue(5, &quot;学分&quot;) grid.SetColLabelValue(6, &quot;课程属性&quot;) grid.SetColLabelValue(7, &quot;课程性质&quot;) grid.SetColLabelValue(8, &quot;获得方式&quot;) # 第一列标签 grid.SetColSize(0,50) grid.SetColSize(1,100) grid.SetColSize(2,100) grid.SetColSize(3,350) grid.SetColSize(4,50) grid.SetColSize(5,50) grid.SetColSize(6,50) grid.SetColSize(7,100) grid.SetColSize(8,100) grid.SetCellTextColour(&quot;NAVY&quot;) data = csu.search() data.remove(data[0]) print(data) for i,item1 in enumerate(data): for j,item2 in enumerate(item1): grid.SetCellValue(i,j,data[i][j]) pass app = wx.App() frame = UI() frame.Show() app.MainLoop() 想要运行代码，具体的配置过程请参考readme运行结果预览如图片不可加载，请点击https://blog.csdn.net/ygdxt/article/details/84591649 源代码地址https://github.com/inspurer/PythonSpider/tree/master/csu]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取b站视频]]></title>
    <url>%2F2018%2F11%2F25%2Fpython%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[python爬虫系列：上一篇python爬取图虫网图库今天突然来了兴趣想要爬取下载b站视频，话不多说，说干就干。 Usage下载仓库git@github.com:inspurer/PythonSpider.git 或者直接下载:https://github.com/inspurer/PythonSpider/tree/master/bilibili 替换随便打开一个b站的界面，比如将url复制到代码中去，运行代码，稍等一会儿，上述图中的视频就被下载下来了。 How to Code分析网页源码按f12浏览器开发者工具 ，通过一番审查，我们定位到视频的url在网页源代码的位置如下： window.__playinfo__={ &quot;from&quot;:&quot;local&quot;, &quot;result&quot;:&quot;suee&quot;, &quot;quality&quot;:32, &quot;format&quot;:&quot;flv480&quot;, &quot;timelength&quot;:408884, &quot;accept_format&quot;:&quot;flv720,flv480,flv360&quot;, &quot;accept_description&quot;:[&quot;高清 720P&quot;,&quot;清晰 480P&quot;,&quot;流畅 360P&quot;], &quot;accept_quality&quot;:[64,32,15], &quot;video_codecid&quot;:7, &quot;video_project&quot;:true, &quot;seek_param&quot;:&quot;start&quot;, &quot;seek_type&quot;:&quot;offset&quot;, &quot;durl&quot;:[{&quot;order&quot;:1,&quot;length&quot;:408884,&quot;size&quot;:42782550,&quot;ahead&quot;:&quot;EhA=&quot;,&quot;vhead&quot;:&quot;AWQAHv/hAB5nZAAerNlA2D3n//AoACfxAAADAAEAAAMAMA8WLZYBAAVo6+zyPA==&quot;, &quot;url&quot;:&quot;http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345&quot;,&quot;backup_url&quot;:[&quot;http://upos-hz-mirrorcos.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?um_deadline=1543136253&amp;platform=pc&amp;rate=176800&amp;oi=1862807981&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;gen=playurl&amp;os=cos&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&quot;]}]} 最后的url就是我们想要的结果。如果在浏览器中查找不方便的话，我们可以把通过代码把网页源码输出到本地 response = requests.get(url=&apos;https://www.bilibili.com/video/av26522634&apos;, headers= self.getHtmlHeaders) print(response.status_code) if response.status_code == 200: print(response.text) 为了伪装成浏览器，我们需要在reqests添加Headers这个Headers需要我们去浏览器中手动获取切换到NetWork标签下，再选择Headers， self.getHtmlHeaders={ &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q = 0.9&apos; } 这里只选择了几个关键的 解析得到视频地址根据上一步分析，我们得到了网页的源码，并在源码中定位到了视频地址，接下来，我们就用代码自动获取这个地址了 #用正则、json得到视频url;用pq失败后的无奈之举 pattern = r&apos;\&lt;script\&gt;window\.__playinfo__=(.*?)\&lt;/script\&gt;&apos; result = re.findall(pattern, html)[0] temp = json.loads(result) #temp[&apos;durl&apos;]是一个列表，里面有很多字典 #video_url = temp[&apos;durl&apos;] for item in temp[&apos;durl&apos;]: if &apos;url&apos; in item.keys(): video_url = item[&apos;url&apos;] 顺便获取下视频的名字： #用pq解析得到视频标题 doc = pq(html) video_title = doc(&apos;#viewbox_report &gt; h1 &gt; span&apos;).text() 然后组合返回下： return{ &apos;title&apos;: video_title, &apos;url&apos;: video_url } 下载视频通过在开发者工具中搜索关键词，比如上面得到的视频url，我们可以定位到在浏览器中真正下载视频的请求在哪然后把它的Headers添加到reqests中，就可以下载视频了 with open(filename, &quot;wb&quot;) as f: f.write(requests.get(url=url, headers=self.downloadVideoHeaders, stream=True, verify=False).content) 愉快地观看本地视频如果你下载的视频在本地播放不了，请不要试图修改源代码中保存文件的格式由.flv改成.mp4,因为b站的视频本来就是flv格式的，需要用特殊的视频播放器播放，这里推荐一个无毒无害的KMPlayer,https://pan.baidu.com/s/1DBOaPGbdTXOvodbrZRhzmQ,提取码：fw0b 源代码工程所有源代码均已上传至github，https://github.com/inspurer/PythonSpider/tree/master/bilibili欢迎star,fork。如图片显示有问题请到csdn观看https://blog.csdn.net/ygdxt/article/details/84501500]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>b站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数的填坑之路]]></title>
    <url>%2F2018%2F11%2F22%2Fpython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[背景最近在看廖雪峰老师的python3教程之函数的参数受益匪浅，但是在实践的过程中，发现了一些不解之谜 两个错误import _thread import time def func1(x): while x: print(x) x = x -1 _thread.start_new_thread(function=func1,args=(5,),kwargs=None) time.sleep(6) 再看python3中start_new_thread()函数的声明 def start_new_thread(function, args, kwargs=None): 按照我们的理论，我们开启多线程的那句代码是完全没有问题的，可是事实上它报错： TypeError: start_new_thread() takes no keyword arguments 难道我们的理论有问题？带着这个疑问，我又遇到一个问题: import threading def func1(x): while x: print(x) x = x -1 threading.Thread(func1,(5,)).start() 再看python3中Thread类构造()函数的声明 def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): 它居然又报错？ AssertionError: group argument must be None for now 探讨过程（以下过程针对第二个错误，第一个错误道理类似）带着疑问，我看了Thread类的构造函数 def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): &quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are: *group* should be None; reserved for future extension when a ThreadGroup class is implemented. *target* is the callable object to be invoked by the run() method. Defaults to None, meaning nothing is called. 。。。略 assert group is None, &quot;group argument must be None for now&quot; 。。。略 我们看到，第三行说明，本函数只接受关键字实参调用，所以我们之前的代码改成 import threading def func1(x): while x: print(x) x = x -1 threading.Thread(target=func1,args=(5,)).start() 就能顺利开启子线程了，那么它是如何实现只能接受关键字参数的呢？我们看到Thread类的构造函数定义中有一句这样的断言 assert group is None, &quot;group argument must be None for now&quot; 意思是，如果参数group为空,通过；如果非空，报错，并给出reasongroup argument must be None for now,如果我们按照之前的位置参数调用的话，由于group是第一个参数，一下在就被赋值，非空，抛出异常，这符合我们之前的实践。同时，我在网上搜集了许多资料，诸如修饰器之类的也能使函数只接受关键字参数 。 错误一探讨过程道理类似，在此不再赘述。 验证及结论编码 class MyThread: def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): print(&apos;Thread sucess&apos;) def start_new_thread(function, args, kwargs=None): print(&apos;_thread sucess&apos;) MyThread() MyThread.start_new_thread(args=2,kwargs=3,function=1) 输出如下： Thread sucess _thread sucess 显而易见，我们之前所学的理论是正确的，只不过在具体的编码中，我们通过编码修改理论，使之看上去似乎和之前的理论相矛盾，千万不要被蒙蔽了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗素:我为什么而活]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%BD%97%E7%B4%A0-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[中文译文对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁而无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。 我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情可以解除孤寂一—那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想像的天堂景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。 我以同样的热情寻求知识，我渴望了解人的心灵。我渴望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。 爱情和知识，尽其可能地把我引上天堂，但是同情心总把我带回尘世。痛苦的呼唤经常在我心中回荡，饥饿的儿童，被压迫被折磨者，被儿女视为负担的无助的老人以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。 这就是我的一生，我觉得值得为它活着。如果有机会的话，我还乐意再活一次。 英文原文《What I Have Lived For》 by Bertrand Russell Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a great ocean of anguish, reaching to the very verge of despair. I have sought love, first, because it brings ecstasy - ecstasy so great that I would often have sacrificed all the rest of life for a few hours of this joy. I have sought it, next, because it relieves loneliness–that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what–at last–I have found. With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved. Love and knowledge, so far as they were possible, led upward toward the heavens. But always pity brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate this evil, but I cannot, and I too suffer. This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李开复:追随我心]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%9D%8E%E5%BC%80%E5%A4%8D-%E8%BF%BD%E9%9A%8F%E6%88%91%E5%BF%83%2F</url>
    <content type="text"><![CDATA[并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫李开复,此君并非厌学,而是对政治科学越来越不感兴趣。蹉跎到大二下学期,他终于决定快刀斩乱麻——转系,改学自己感兴趣的计算机。 兴趣是什么?兴趣就意味着天赋。李开复在计算机系如鱼得水,左右逢源,两年后毕业,成绩居全系之首。这样的学生用不着按部就班。在教授的推荐下,李开复进入在计算机领域独领风骚的卡内基•梅隆大学,直接攻读博士。计算机学院的院长找他谈话,劈头就问:“读博士的目的是什么?”李开复大声答:“我从大学带走的将是一篇改变世界的、顶尖的博士论文。”院长予以纠正,说:“你从这儿带走的最有价值的东西,不是一篇论文,而是你分析、思考的能力,研究、发现真理的经验,以及科学家的胸怀。这样,当你有一天改变研究方向,依然可以在任何一个新的领域出类拔萃。”李开复选定语音识别为攻读方向,经过一年“热恋”,他发现专家系统其冷如冰,远不如统计学有情有义。李开复决心“移情别恋”。他担心导师发怒,谁知得到的回答竟是:“开复,你对专家系统和统计的观点,我是不赞同的,但我可以支持你用统计的方法去做,因为我相信科学没有绝对的对错,我们都是平等的。而且,我更相信一个富有激情的人可以找到更好的解决方案。”李开复从导师的大度悟到科学的真谛,他全力以赴,放手一搏。3年过去了,李开复的研究成果及博士论文,引发了那年语音世界最大的冲击波。26岁的李开复功成名就,成为卡内基•梅隆大学最年轻的副教授。天之骄子,有尊严,有地位,有课题,有经费,出任大公司顾问,飞赴各地讲学,包括去他的祖籍之邦、魂之所系的祖国大陆。 “让世界因你而不同!”这是李开复埋在心底多年的梦想。1990年,苹果公司的一个邀请电话让李开复开始审视自己:“开复,你是想一辈子写一堆像废纸一样的学术论文,还是想真正地改变世界?”面对苹果公司的召唤,李开复旋即做出回应,走出象牙塔,加盟“改变世界”的大军。在苹果公司,李开复感受到了从纸上谈兵转入实战的无穷乐趣。1995年,33岁的李开复出任苹果公司的副总裁。 但是他仍然不满足,依然要跳槽,因为硅谷的另一家公司SGI发出了更有诱惑力的邀请——“你想做什么,然后我们根据你的兴趣对公司进行改组。”不是他们缺什么人才,让你去填补,而是诚恳地询问你需要什么平台,以便为你量身搭建。这样的机遇,李开复岂能错过!双方一拍即合, 1996年7月,李开复跳槽去了SGI。李开复奉行“自己设计自己”的人生信条,怎奈SGI是一家硬件公司,开复的长处却在软件开发,这就等于在篮球场上跑马,任是赤兔、骅骝,也撒不开四蹄。日复一日,李开复萌生去意。对于下一个选择,他立下两条标准:一是做软件,二是去中国。 机会来了。其实机会无处不在,就看你有没有做好准备。彼时,比尔•盖茨创立的微软王国要把触角伸向中国,李开复成为它的不二人选。时间:1998年金秋;职务:微软中国研究院院长。李开复在中国市场的开拓,值得写部书来描述,那是一种完全不同的创新理念、绝对领先的科学技术在神州大地生根发芽。微软只是起用了一个人,就开拓了中国市场;李开复只是“追随我心”,就一跃成为微软王国的副总裁。在你我想来,这该是李开复的最后一站。在微软占据高位,与比尔•盖茨亲密共事,坐拥财富和风光,“花迎喜气皆知笑,鸟识欢心亦解歌”。人生至此,夫复何求?李开复不这么想,他后来回忆:“我如同一部庞大机器上的零件,在中规中矩、没有任何发挥空间的环境下运行着。这是一个随时随地都可以被替换的光鲜零件。那种价值的缺失感以及精神上的落寞占据了我的内心。”微软既然已无成长空间,那就走吧!到哪儿去?他相中了Google。但他清醒地意识到,管理更多的人马,不是自己的所爱,他渴望从无到有的创新,而不是经营一个巨无霸。于是,在2009年9月,李开复又一次选择潇洒地离去。向总部递交辞呈之际,Google高管艾伦•尤斯塔斯试图用更优厚的条件予以挽留。李开复真诚地说:“我的人生还有一个缺憾没有实现,现在得去弥补。我可能创办一家‘创新工场’,和中国青年一起创造新的技术奇迹。” 如今,李开复正在按照他本人的意愿,在神州大地进行“创新工场”试验。他会成功吗?我想这是毫无疑问的,也是次要又次要的,那么,最主要的一点是什么呢?诚如他自己所言:“人生在世时间非常短,如果你总是不敢做想做的事情,那么一生过去了,你留下来的只有悔恨,只有懊恼。”“我步入丛林,因为我希望生活得有意义,我希望活得深刻,并汲取生命中所有的精华,然后从中学习,以免让我在生命终结时,才发现自己从来没有活过。”]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
        <tag>励志故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python自动下载图虫网图库]]></title>
    <url>%2F2018%2F11%2F14%2Fpython%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[如何使用下载工程源码点击下载或者git bash;git clone git@github.com:inspurer/PythonSpider.git 下载相关依赖在命令行下依此输入 pip install requests pip install pyquery 打开图虫网选择你喜欢的图库链接,比如https://tuchong.com/4293835/23849565/复制并替换到tuchong_gallery.py代码里面的gallery_url,解释一下这个链接的作用,前一个数字串是作者的id,后一个数字串是作者该图库的id注意,在打开这个图库时,复制地址前最好不要左右浏览 运行tuchong_gallery.py你就可以看到在下载这个图库的图片了图库保存在工程目录下,文件夹名为作者和图库的id每一张图片保存在该文件夹下,格式为:imageid.jpg 计划更新增加自动搜索]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序json.parse错误]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8Fjson-parse%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[错误详情今天查看上线的微信小程序后台，发现了一个这样的错误: Unexpected token in JSON at position 52; at pages/send/send onShow function; at api request success callback function 于是我打开调试工具查看源代码并且调试:VM792:1 thirdScriptError Unexpected token in JSON at position 52;at pages/send/send onShow function; at api request success callback function SyntaxError: Unexpected token in JSON at position 52 at JSON.parse (&lt;anonymous&gt;) at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35) at http://127.0.0.1:60162/appservice/utils/bmob.js:2293:37 at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2219:48) at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34 at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17) at Bmob.Promise.resolve (http://127.0.0.1:60162/appservice/utils/bmob.js:2170:18) at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2228:37) at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34 at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17) 果不其然,小程序已然上线,这个错误一定不能忍 调试过程通过错误信息定位到出错的代码通过上面的报错信息：at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35)定位到出错的代码是在130行:var jsonB = JSON.parse(jsonA); 上网浏览查询相关资料网上的说法不一而足,实在不知道该听信哪家之言不过都集中在json文件不能有注释、json字符串url有误、json字符串有特殊字符 定位原因排除了几种错误后还没有解决问题，有点心灰意冷,尝试着输出json字符串中的每一个字符 51 &quot;。&quot; 52 &quot; &quot; 53 &quot;2&quot; 等等,换行符确是是个特殊字符(ps,在js里面\r是回车符,\n是换行符,)(在小程序中,我这个jsonA是包含用户的键盘输入信息的) 解决办法jsonA = jsonA.replace(&apos;\n&apos;,&apos;&apos;) 后话小程序的预览可以查看: 点击查看小程序的所有源代码: github地址]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】hexo next主题优化手册]]></title>
    <url>%2F2018%2F11%2F11%2Fhexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言开此贴的原因前几天博客崩了，重新搭建了这个博客站点。特开此贴记录next主题优化过程中遇到的问题，希望对大家有所帮助。 一些说明前期相关的Hexo安装、本地/远程部署教程可百度在此不再赘述。基于hexo-next v5.1.4,向上兼容,向下兼容性不确定，特此声明。我的博客本地根目录是D:\hexoblog站点配置文件全路径是‪D:\hexoblog\_config.ymlnext主题文件全路径是‪D:\hexoblog\themes\next\_config.yml hexo常见操作hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 next主题优化next风格选择next有四种风格,在站点配置文件搜索字段Scheme Settings可以看到， # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 我这里用的是四种：Gemini next菜单设置比如可以看到我的主页有首页、留言、分类、归档、标签等菜单，在站点配置文件下搜索menu:,可以看到 menu: home: / || home about: /about/ || user message: /message/ || comment tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat home就是首页;message就是留言…一开始只有首页和归档,其余的需要我们手动创建，在站点根目录下打开命令行,输入hexo new page &quot;about&quot;并在主题配置文件menu:字段处取消对about的注释重新部署我们就可以看到主页有关于这个菜单了，其他的类似，修改D:\hexoblog\source\about\index.md,就可以修改关于界面了about: /about/ || user中的user是指关于菜单附件的图标用的是图标库里面名为user的图标 添加萌妹子动图在根目录下打开命令行输入npm install --save hexo-helper-live2d 修改站点配置文件(注意不是主题配置文件)在末尾加入: live2d: enable: true scriptFrom: local model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: false react: opacityDefault: 0.5 opacityOnHover: 0. 实现文章首页”分类于”、”阅读次数”等效果效果图如下: 在根目录下打开命令行依次输入以下命令: npm install hexo-wordcount --save npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 打开主题配置文件打开相关开关: post_wordcount: item_text: true wordcount: true min2read: true totalcount: true 打开…/themes/next/layout/_macro/post.swig文件把里面的代码用下面的代码替换:点击下载 打开…/themes/next/languages/zh-Hans.yml文件搜索post字段,添加一行comments: 评论数,注意其余的不要改 设置某篇文章置顶前面的流程走完后,只需要在写文章的时候在文章前面加入top: true或者top: 100(100只是个例子，数字越大越靠前),就能实现置顶效果了 常见错误本地预览和同时发布到远程的浏览结果不一致这是由缓存造成的,需要先hexo clean,再hexo g -d部署到远程 markdown高级语法插入连续多行的代码块按一个tab键,然后贴代码，保证每一行代码前都要额外的tab键,同时最前面空一行。比如,我前面插入的连续行代码的实现效果: 设置文字大小和颜色和居中效果hello,world! hello,world! hello,world! hello,world! hello,world!上面的效果需要在markdwon中的代码是这样的: hello,world! &lt;font color=&quot;#FF0000&quot;&gt; hello,world! &lt;/font&gt; &lt;font size=5&gt; hello,world! &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt;hello,world! &lt;/font&gt; &lt;center&gt;hello,world!&lt;/center&gt; 插入表格效果图: 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 markdown代码如下： | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | 感谢赞助所有赞赏过本站的人: 点击查看]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下操作POP3]]></title>
    <url>%2F2018%2F11%2F10%2FWindows%E4%B8%8B%E6%93%8D%E4%BD%9CPOP3%2F</url>
    <content type="text"><![CDATA[Windows10下开启telnet服务在自学《计算机网络-自顶向下方法》这本书中，telnet这个服务命令出现了好多次， 开始在Ubuntu 12.0终端下输入telnet是有正确响应的，但是在windows 10命令行下输入提示找不到该命令，直到今天我才发现该服务在window 1o下是默认关闭的，需要手动打开开启步骤如下 1.用小娜以关键词功能找到开启和关闭Windows功能其实不一定要这样操作，找到开启和关闭Windows功能即可 2.勾选Telnet客户端并确定然后就可以愉快地在windows10玩耍telnet了 Windows下操作POP3pop3是一个邮件访问协议 1.在cmd下输入telnet pop3.163.com 110登录到qq的POP3服务器的110端口2.依次输入user csu_xiaotao和pass xxxxxxxxx登录到自己的邮箱需要注意的是,xxxxxxxxx是邮箱的授权码，不是登录密码 3.然后是一些常见的pop3命令(大小写敏感）1.list列出所有的收到的邮件，特别的`list n’列出第n封邮件其响应格式如下:n m其中n为第n封邮件，m为第n封邮件的字节大小 2.retr n下载第n封邮件其响应格式如下：采用了特殊的编码格式，我们可能看不懂 3.dele n删除第n封邮件4.uidl n返回第n封邮件的唯一标识5.quit退出注意+OK代表操作成功；-ERR代表操作失败]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>pop3</tag>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打卡微信小程序]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[打卡微信小程序。实现功能1、类似论坛，可发帖、评论、回复。 2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。3、跑步也可换算积分，换算的规则男女有别。实现效果 核心js代码1 var Bmob = require(&quot;../../utils/bmob.js&quot;); var common = require(&quot;../../utils/common.js&quot;); Bmob.initialize(&quot;*************************&quot;, &quot;**************************&quot;); Page({ /** * 页面的初始数据 */ data: { canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;), hiddenmodalput: true, cname: &apos;&apos;, sexx: &apos;&apos;, iname: &apos;&apos;, }, cancel: function(e){ wx.showToast({ title: &apos;务必输入&apos;, icon: &apos;loading&apos; }) }, cn:function(e){ console.log(e.detail.value) this.setData({ cname: e.detail.value }) }, se: function (e) { console.log(e.detail.value) this.setData({ sexx: e.detail.value }) }, ina: function(e){ this.setData({ iname:e.detail.value }) }, confirm: function (e) { var that = this; if (!(that.data.sexx == &apos;男&apos; || that.data.sexx == &apos;女&apos;)){ wx.showToast({ title: &apos;性别输入有误&apos;, }) return; } if(!that.data.cname){ wx.showToast({ title: &apos;姓名班级有误&apos;, }) return; } if(that.data.iname.length&gt;0) { var User = Bmob.Object.extend(&quot;_User&quot;); var query = new Bmob.Query(User); query.equalTo(&apos;nickname&apos;, that.data.iname) query.find({ success: function (results) { if (results.length == 0) { wx.showToast({ title: &apos;无此邀请人&apos;, icon: &apos;loading&apos; }) return; } var user = Bmob.User.logIn(results[0].get(&apos;username&apos;), results[0].get(&apos;userData&apos;).openid, { success: function (users) { var score = users.get(&apos;score&apos;); score = score + 2; users.set(&apos;score&apos;, score); users.save(null, { success: function (user) { wx.showToast({ title: &apos;被邀请成功&apos;, icon: &apos;success&apos; }) }, error: function (error) { console.log(error) } }); } }); } }) } this.setData({ hiddenmodalput: true, }) wx.getStorage({ key: &apos;my_username&apos;, success: function (ress) { if (ress.data) { var my_username = ress.data; wx.getStorage({ key: &apos;user_openid&apos;, success: function (openid) { var openid = openid.data; var user = Bmob.User.logIn(my_username, openid, { success: function (users) { users.set(&apos;nickname&apos;, that.data.cname); users.set(&apos;sex&apos;,that.data.sexx) users.save(null, { success: function (user) { wx.setStorageSync(&apos;my_nick&apos;, that.data.cname); wx.setStorageSync(&quot;sex&quot;, that.data.sexx); }, error: function (error) { console.log(error) } }); } }); }, function(error) { console.log(error); } }) } } }) wx.switchTab({ url: &apos;../punch/punch&apos;, }); }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, bindGetUserInfo: function (e) { var that = this; // 查看是否授权 wx.getSetting({ success: function (res) { if (res.authSetting[&apos;scope.userInfo&apos;]) { console.log(&quot;已授权&quot;) // 已经授权，可以直接调用 getUserInfo 获取头像昵称 //调用API从本地缓存中获取数据 try { var value = wx.getStorageSync(&apos;user_openid&apos;) if (value) { console.log(&quot;value不为空&quot;) wx.switchTab({ url: &apos;../punch/punch&apos;, }) } else { console.log(&quot;value为空&quot;) wx.login({ success: function (res) { console.log(&apos;res&apos;, res) if (res.code) { Bmob.User.requestOpenId(res.code, { success: function (userData) { console.log(&apos;uD&apos;,userData) var userInfo = e.detail.userInfo; var nickName = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; Bmob.User.logIn(nickName, userData.openid, { success: function (user) { try { console.log(&apos;sex&apos;+user.get(&apos;sex&apos;)); console.log(&apos;score&apos; + user.get(&apos;score&apos;)); wx.setStorageSync(&quot;newsnum&quot;, user.get(&apos;newsnum&apos;)) wx.setStorageSync(&quot;sex&quot;, user.get(&apos;sex&apos;)); wx.setStorageSync(&quot;score&quot;, user.get(&apos;score&apos;)); wx.setStorageSync(&apos;user_openid&apos;, user.get(&quot;userData&quot;).openid) wx.setStorageSync(&apos;user_id&apos;, user.id); wx.setStorageSync(&apos;my_nick&apos;, user.get(&quot;nickname&quot;)) wx.setStorageSync(&apos;my_username&apos;, user.get(&quot;username&quot;)) wx.setStorageSync(&apos;my_avatar&apos;, user.get(&quot;userPic&quot;)) } catch (e) { } console.log(&quot;登录成功y&quot;); }, error: function (user, error) { console.log(&apos;test&apos;,error) if (error.code == &quot;101&quot;) { that.setData({ hiddenmodalput: false, }) var user = new Bmob.User();//开始注册用户 user.set(&quot;username&quot;, nickName); user.set(&quot;password&quot;, userData.openid);//因为密码必须提供，但是微信直接登录小程序是没有密码的，所以用openId作为唯一密码 user.set(&quot;sex&quot;,&quot;男&quot;); user.set(&quot;score&quot;,0); user.set(&apos;newsnum&apos;,0); user.set(&quot;nickname&quot;, nickName); user.set(&quot;userPic&quot;, avatarUrl); user.set(&quot;userData&quot;, userData); user.signUp(null, { success: function (results) { try {//将返回的3rd_session储存到缓存 wx.setStorageSync(&apos;user_openid&apos;, results.get(&quot;userData&quot;).openid) wx.setStorageSync(&apos;user_id&apos;, results.id); wx.setStorageSync(&apos;my_username&apos;, results.get(&quot;username&quot;)); wx.setStorageSync(&quot;newsnum&quot;, results.get(&apos;newsnum&apos;)); wx.setStorageSync(&quot;score&quot;, 0); wx.setStorageSync(&quot;sex&quot;, &quot;男&quot;); wx.setStorageSync(&apos;my_nick&apos;, results.get(&quot;nickname&quot;)); wx.setStorageSync(&apos;my_avatar&apos;, results.get(&quot;userPic&quot;) ) console.log(&quot;注册成功!&quot;); } catch (e) { } }, error: function (userData, error) { console.log(error) } }); } } }); }, }); } else { console.log(&apos;获取用户登录态失败！&apos; + res.errMsg) } }, }); } } catch (e) { console.log(&quot;登陆失败&quot;) } wx.checkSession({ success: function () { }, fail: function () { //登录态过期 wx.login() } }) } } }) }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** * 生命周期函数--监听页面显示 */ onShow: function () { }, /** * 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** * 生命周期函数--监听页面卸载 */ onUnload: function () { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { wx.stopPullDownRefresh() }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** * 用户点击右上角分享 */ onShareAppMessage: function () { } }) ``` ` github地址,欢迎star、fork!!!]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于opencv人脸识别的员工考勤系统]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%9F%BA%E4%BA%8Eopencv%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84%E5%91%98%E5%B7%A5%E8%80%83%E5%8B%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[WorkAttendanceSystem一个基于opencv人脸识别的员工考勤系统，作者某双一流A类大学里的二流学生，写于2018/09/，python课设期间。 工程简介项目结构是V1.0版本的，V2.0的介绍请看文末更新版块项目结构mainui.py是主界面，调用face_img_register.py和face_recognize_punchcard.py其中face_img_register.py是录入人脸信息，face_recognize_punchcard.py是刷脸考勤face_feature_storage.py属于鸡肋文件，没什么用，舍不得删，毕竟有点参考价值。face_recognize_punchcard_lib.py和face_recognize_punchcard.py本质上差不多，但是前者是给face_img_register.py专有的依赖。防止录入两个同样的人脸建不同数据库的风险。 运行效果1. 主界面 2. 人脸录入 3. 刷脸考勤 其余的就不多做展示了，有什么问题欢迎2391527690@qq.com联系 更新V1.0版本2018/9/23更新mainui.py–&gt;myapp.pyface_recognize_punchcard_lib.py等鸡肋文件放到useless文件夹里运行效率显著提高 2018/9/25更新解决同步性问题，新录入的人脸能立即被识别代码的运行速度少许下降 V2.0版本1. 全新设计的UI,更人性化的操作 2. 数据更加安全，用户不可见人脸数据和签到日志全部保存在inspurer.db数据库文件里，更加安全；而且对人脸数据进行了压缩，更加小巧。 3. 注意事项 打开摄像头时请左右晃动一下人脸，确保人脸识别开始。 人脸识别时做了拒绝处理，多张人脸时，只取距离屏幕最近的人脸。 新建录入时会自动录入十张人脸照片，也可手动点击完成录入立即完成，之后就会计算人脸数据并存储到数据库中，左边的信息栏会有相应的信息打印。 开始签到后，如不点击结束签到,就会一直对屏幕前的人脸进行签到，签到状态分三种,未识别的人脸，签到成功，签到成功但是迟到了(9.00后签到),重复签到(此时签到日志不会写入到数据库。 为确保程序稳定性，每一个菜单里的按钮尽量成对操作。 Thanks for your attention;can you fork it if helping you? Thanks again！CopyRight 2391527690@qq.com;send me for allowance if you want to transmit it 源代码地址github]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之单链表]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从今天起开始数据结构系列的分享，今天分享的是单链表。单链表大概是大概是每个数据结构初学者的必经之路，下面结合一个小小的工程来深入学习单链表的使用–简易客户管理系统。ps：如果还不清楚单链表是什么的小伙伴自行百度，在此不在赘述 #项目结构如图所示大致了解了项目架构后，下面开始从零编写代码注：增、删、改这三个部分同时包含了将变动后的信息写入到文件中的操作 #代码编写 ##项目基础代码俗话说得好，“万丈高楼平地起”，先来编写项目的预定义代码部分，主要是头文件包含、结构体定义、全局变量定义等 ###头文件包含#include&lt;stdio.h&gt; //C程序基础库#include&lt;stdlib.h&gt; //包含函数exit()#include&lt;string.h&gt; //包含函数strcmp() ###结构体定义 typedef struct item{ char name[20]; //保存客户姓名 char gender[20]; //保存客户性别 int age; //保存客户年龄 char tel[20]; //保存客户号码} guest;结构体定义不要多说了哈，这里typedef...guest是给结构体item起别名的意思，也就是struct item在这个源文件里面等价于guest typedef struct node { guest data; //数据域 struct node next; //指针域} link;这里是给指向结构体node的指针起别名 ###全局变量定义link T;//头指针这个头指针T是整个系统的索引，六个模块共有一个，虽然有尽量少定义全局变量的原则，但这里的全局变量T可以避免各个函数间复杂的参数传递问题，牺牲了空间，换取了运行时间的减少；同时要注意我在后面对T的初始化代码 //初始化头指针T=(link)malloc(sizeof(struct node));T-&gt;next = NULL;这里并没有给T安排数据域，T不是第一个存储客户信息的节点指针，T-&gt;next才是，初始化头指针时还没有存储客户信息的结点加入，所以T-&gt;next=NULL;,这是一个编程者应该养成的好习惯；为什么不给T安排数据域呢，这里主要考虑到后面的删除模块的编写，我们知道，删除一个结点，要先找到这个结点的前驱指针p和后驱指针q，然后p-&gt;next = q-&gt;next；,如果给T安排数据域的话，T的前驱是什么呢？就算不用上面我说的那套删除逻辑，用if...else...语句和另外一套逻辑完成对T的删除，代码明显复杂些。 ##项目核心代码 ###一、加载文件代码如下 void init() { link p,s; FILE *fp; int i = 0; s = p=(link)malloc(sizeof(struct node)); p-&gt;next = NULL; if((fp=fopen(“1.txt”,”r”))==NULL) { printf(“load error!”); exit(1); } while(!feof(fp)) { fscanf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,&amp;p-&gt;data.age,p-&gt;data.tel); i++; if(i!=1) { s-&gt;next = p; s=p; } else{ T-&gt;next = p; } p=(link)malloc(sizeof(struct node)); p-&gt;next = NULL; } printf(“总人数i=====%d\n”,i); if(fclose(fp)) { printf(“Can’t close the file!\n”); exit(1); }}介绍下代码逻辑，新开辟内存空间，并使s、p指向它，打开文件，如果文件指针没有到文件尾，将从文件读取到的一个客户信息赋给p的数据域，如果是读取第一个客户信息，将p指向的结点连在头指针T后面，否则，将p连在s后面，因为这个时候s是p的前驱指针，连接成功后将p赋值给s，p又指向一个新开辟的结点…图示： ###二、增加客户代码如下： //添加void create() { link p,s; FILE *fp; int yn; s=T; while(s-&gt;next!=NULL) { s=s-&gt;next; } do { p=(link)malloc(sizeof(struct node)); printf(“请输入客户姓名：\n”); scanf(“%s”,p-&gt;data.name); printf(“请输入客户性别：\n”); scanf(“%s”,p-&gt;data.gender); printf(“请输入客户年龄：\n”); scanf(“%d”,&amp;p-&gt;data.age); printf(“请输入客户联系方式：\n”); scanf(“%s”,p-&gt;data.tel); p-&gt;next=NULL; s-&gt;next=p; s=p; if((fp=fopen(“1.txt”,”at”))==NULL) { printf(“write error!\n”); exit(0); } printf(“写了一次\n”); fprintf(fp,”%s\t%s\t%d\t%s\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel); if(fclose(fp)) { printf(“can’t close the file!\n”); exit(0); } printf(“添加成功!\n”); printf(“是否继续添加请输入0或1:”); scanf(“%d”,&amp;yn); } while(yn);}代码逻辑很简单，新增结点，并连在尾节点后面，同时写入文件，如果前一片代码看懂了，这不是什么大问题… ###三、删除客户代码如下 //删除int del() { link p,q; FILE *fp; char mod[25]; printf(“请输入需要删除的客户名称:\n”); scanf(“%s”,mod); p=T; while(p-&gt;next!=NULL&amp;&amp;strcmp(p-&gt;next-&gt;data.name,mod)!=0) p=p-&gt;next; if(p-&gt;next==NULL) { printf(“并无此人！\n”); return 0; } q = p; p = p-&gt;next; q-&gt;next = p-&gt;next; delete(p); printf(“删除成功！\n”); if((fp=fopen(“1.txt”,”wt”))==NULL) { printf(“error!\n”); exit(0); } p=T-&gt;next; while(p!=NULL) { printf(“%s”,p-&gt;data.name); fprintf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel); p = p-&gt;next; } if(fclose(fp)) { printf(“can’t close the file!\n”); exit(1); }}模块三、四、五、六道理类似，不再赘述附上代码地址：github 欢迎star如有疑问，欢迎进群讨论：如链接失效，扫二维码：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门第二天]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[前言许久未更新了，今天七夕，为了逃避现实，重启博客。本博客主要记录一些前端学习中的入门级问题。 正文Q1：HTML标签、元素、属性都是什么概念？HTML标签：HTML标签标记了HTML文档和HTML元素，HTML标签由开始标签和结束标签组成.开始标签为尖括号包围的元素名,结束标签为尖括号包围的斜杠和元素名。例如:&lt;h2&gt; My First Heading&lt;/h2&gt; HTML元素：HTML文档是由html元素定义的.HTML的元素是指从开始标签到结束标签的所有代码..例如:&lt;p&gt;我是一个段落&lt;/p&gt;表示一个html元素.可以看出,html元素主要包括html标签和纯文本.标签定义网页显示的格式,文本表示网页的内容.故此,网页 = html文档,而html文档则是由html元素定义的. HTML属性：HTML属性为HTML元素提供附件信息,例如在超链接标签&lt;a href = “https://inspurer.github.io&gt;月小水长的个人博客&lt;/a&gt;使用了href属性来指定超链接的地址.属性总是以名称/值的形式出现,例如:name = “value”属性总是在开始标签中定义. Q2：meta标签都用来做什么的？ 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 Q3： Web语义化是什么，是为了解决什么问题？简言之，web语义化的目的是提高计算机和人对web代码的可读性。 网上的解释很多，个人总结分三个阶段比较容易理解。1、原始的一些有实际含义的标签定义。浏览器和W3C组织推出的如h1~h6、thead、ul、ol的HTML标签用于在Web页面中组织对应的内容，如网页标题、表头、无序、有序列表，以达到更方便的协作及传播互联网内容的目的。搜索引擎很好的利用了这些语义化标签抓取内容，又鉴于搜索引擎的巨大流量推荐，Web前端不得不考虑SEO，从而两者实现有益的循环，共同推进着语义化标签的使用。 2、前端开发人员自定义的标签。但Web的发展超乎想象，起初定义的HTML语义化标签，不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer“或者class=”footer”的属性（值），以“无声”的方式 在不同的前端程序员或者前后端程序员间实现交流。 3、在第二步的推动下结合新技术出现的一些标签。W3C组织意识到了之前HTML版本的不足，推出的HTML5进一步推进了Web语义化发展，采用了诸如footer、section等语义化标签，弥补了采用id=”footer”或者class=”footer”形式的不足，以更好的推动Web的发展。正所谓：世上本没有路，走的人多了，也便成了路。 Q4: 表单标签都有哪些，对应着什么功能，都有哪些属性?还是W3School的这篇教程经典：HTML表单标签之input Q5: ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方?举个例子.1.无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于 &lt;ul&gt;标签。每个列表项始于 &lt;li&gt;。 2.有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 &lt;ol&gt;标签。每个列表项始于&lt;li&gt; 标签。` Coffee Milk `浏览器显示如下 3.定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 &lt;dl&gt;标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以&lt;dd&gt; 开始。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门杂记]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言从今天开始在本教程上纪录当日学到的知识点，不追求百科全书式的纪录只记录那些我比较陌生的或者觉得比较容易混淆的 笔记正文 先来纪录一个坑，用notepad++写出第一个html文档时，代码如下保存为html文件，在火狐浏览器打开，发现文档的内容这几个字是乱码不是utf-8/cp36的问题，而是必须这个html文档必须要BOM头 太累了，后续更新…2018/6/13深夜]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门第一天]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[前言前不久在网上看到一篇Hexo建站的教程，顺手给自己建了个个人博客 有还算扎实的c++/java/python/andorid基础，整个建站过程还算顺利从此沉迷web编程,但是我感觉用现成的框架,总有点那啥受制于人的感觉打算好好学一下前端，由于在实验室跟着老师做项目一直没有时间但是万万没想到，心心念念的前端，开始正式开始系统学习居然是在忙到炸的期末考试周在此要先pick一下百度前端技术学院,可以说是我的前端入门导师了哈哈哈，不bb了，正式开始。 首先我们要知道访问网站的具体过程比如，输入http://www.zhihu.com/question/22689579访问过程如下图所示浏览器和服务器交流，服务器和数据库交流（有时候数据库就在服务器那台机子上）浏览器给服务器发一个请求，服务器不是一看就知道怎么响应的。首先这些请求和响应要有一个通用的写法，也就是要有一个协议，常用的是HTTP协议。像最前面的图，服务器的响应写了一个状态码200 OK,是HTTP协议里约定俗成的一个东西，服务器写200 OK在响应里，表示“你请求的这个东西我有”，如果是404 Not Found，就是“你请求的这个东西我这里没有”。HTTP响应里还包括很多东西，比如Content-type表示服务器发过来的文件类型是什么（文本？动画？图片？音频？）形象化Http响应，大概这样： 然后我们来了解前端三剑客 html 接上图，服务器返回html（就是上图HTTP响应的body里的内容)文件 后,电脑拿到html后，浏览器就会对它进行解析渲染，html是一种文本标记语言，举个栗子： css 浏览器拿到这些代码之后，分析一下给你渲染好页面显示出来，但是如果没有用css，效果是这样的，按照浏览器默认的样式显示出列表、图片、超链接、输入框、按钮等等：是不是觉得默认样式有点看瞎狗眼呢……所以很多时候我们需要自定义样式，现行通用的规定样式的语言是CSS，我们可以用它写一些定义样式的代码，在 html 文件里用一个标签把这些规定样式的CSS代码与表达内容语义的HTML代码关联起来，然后你就能看到一个符合人类正常审美的页面了:插一句：CSS 代码的格式基本是属性 : 值 javascipt(js)有了表示内容和语义的 HTML，规定样式的 CSS，得到的是一个静态的页面，没什么动画（其实用 CSS 还是可以有一些动画的,不过这个跑题了),按 F5 才会刷新数据，于是我们有了 Javascript(js)来给页面添加一些动态的效果浏览器都会帮你实现一些 JS 可以用的工具（函数，对象什么的），你只要写一些js的代码，保存在xxx.js 里，在html文件中用 &lt;script&gt;关联进来就可以用了 在前端三剑客bb了怎么多，可以用一句很形象的话来归纳之：前台三剑客，html是名词，css是形容词，javascript是动词。三个互相配合才是一句子就问形不形象 立个Flag考虑到三周的期末周，就立一个这样的flag吧：暑假每天至少学习前端两个小时，争取下学期开始学完！ 致谢最后实名pick一下小姐姐张秋怡,感谢她的精彩回答我只是个搬运工只不过经过自己的理解稍作了修改2018/6/12 00:31初稿欢迎评论啊]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”月小水长“和“inspurer”的由来]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%9C%88%E5%B0%8F%E6%B0%B4%E9%95%BF%E7%9A%84%E7%94%B1%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[非凭空臆想,其有典故；宋苏轼在后赤壁赋有云：山高月小，水落石出曾日月之几何，而江山不可复识矣在此我引申出月小水长句，一为不怕贻笑大方而附庸风雅，二为吾全名肖涛之字析，月小为肖，水即三点水，长寿为涛，还算是能够自圆其说。至于inspurer,大一的时候了解到一家很厉害的中国企业inspur浪潮想不到中国除了华为还有在高新技术领域耕耘了这么深的企业，遂起名inspurer，寓意弄潮儿，想成为那种站在技术潮头的人儿呐~]]></content>
      <categories>
        <category>生活志</category>
      </categories>
  </entry>
</search>
